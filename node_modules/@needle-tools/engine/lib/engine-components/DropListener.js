var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { AxesHelper, Box3, Object3D, Vector2, Vector3 } from "three";
import { isDevEnvironment } from "../engine/debug/index.js";
import { AnimationUtils } from "../engine/engine_animation.js";
import { addComponent } from "../engine/engine_components.js";
import { destroy } from "../engine/engine_gameobject.js";
import { Gizmos } from "../engine/engine_gizmos.js";
import * as files from "../engine/engine_networking_files.js";
import { serializable } from "../engine/engine_serialization_decorator.js";
import { fitObjectIntoVolume, placeOnSurface } from "../engine/engine_three_utils.js";
import { getParam } from "../engine/engine_utils.js";
import { Animation } from "./Animation.js";
import { Behaviour } from "./Component.js";
import { EventList } from "./EventList.js";
const debug = getParam("debugdroplistener");
export var DropListenerEvents;
(function (DropListenerEvents) {
    /**
     * Dispatched when a file is dropped into the scene. The detail of the event is the file that was dropped.
     */
    DropListenerEvents["FileDropped"] = "file-dropped";
    /**
     * Dispatched when a new object is added to the scene. The detail of the event is the glTF that was added.
     */
    DropListenerEvents["ObjectAdded"] = "object-added";
})(DropListenerEvents || (DropListenerEvents = {}));
/** The DropListener component is used to listen for drag and drop events in the browser and add the dropped files to the scene
 * It can be used to allow users to drag and drop glTF files into the scene to add new objects.
 *
 * ## Events
 * - **object-added** - dispatched when a new object is added to the scene
 * - **file-dropped** - dispatched when a file is dropped into the scene
 *
 * @example
 * ```typescript
 * import { DropListener, DropListenerEvents } from "@needle-tools/engine";
 *
 * const dropListener = new DropListener();
 *
 * gameObject.addComponent(dropListener);
 * dropListener.on(DropListenerEvents.FileDropped, (evt) => {
 *   console.log("File dropped", evt.detail);
 *   const file = evt.detail as File;
 * });
 *
 * dropListener.on(DropListenerEvents.ObjectAdded, (evt) => {
 *    console.log("Object added", evt.detail);
 *    const gltf = evt.detail as GLTF;
 * });
 * ```
 */
export class DropListener extends Behaviour {
    /**
     * When assigned the Droplistener will only accept files that are dropped on this object.
     */
    dropArea;
    /**
     * When enabled the object will be fitted into a volume. Use {@link fitVolumeSize} to specify the volume size.
     * @default false
     */
    fitIntoVolume = false;
    /**
     * The volume size will be used to fit the object into the volume. Use {@link fitIntoVolume} to enable this feature.
     */
    fitVolumeSize = new Vector3(1, 1, 1);
    /** When enabled the object will be placed at the drop position (under the cursor)
     * @default true
     */
    placeAtHitPosition = true;
    onDropped = new EventList();
    /** @internal */
    onEnable() {
        this.context.renderer.domElement.addEventListener("dragover", this.onDrag);
        this.context.renderer.domElement.addEventListener("drop", this.onDrop);
        window.addEventListener("keyup", this.handlePaste);
        this.context.connection.beginListen("droplistener", this.onNetworkEvent);
    }
    /** @internal */
    onDisable() {
        this.context.renderer.domElement.removeEventListener("dragover", this.onDrag);
        this.context.renderer.domElement.removeEventListener("drop", this.onDrop);
        window.removeEventListener("keyup", this.handlePaste);
        this.context.connection.stopListen("droplistener", this.onNetworkEvent);
    }
    onNetworkEvent = (evt) => {
        if (evt.guid?.startsWith(this.guid)) {
            const url = evt.url;
            if (url) {
                if (Array.isArray(url)) {
                    for (const _url of url) {
                        this.addFromUrl(_url, { screenposition: new Vector2() }, true).then(res => {
                            res?.position.set(evt.point.x, evt.point.y, evt.point.z);
                        });
                    }
                }
                else {
                    this.addFromUrl(url, { screenposition: new Vector2() }, true).then(res => {
                        res?.position.set(evt.point.x, evt.point.y, evt.point.z);
                    });
                }
            }
        }
    };
    handlePaste = async (evt) => {
        if (this.context.connection.allowEditing === false)
            return;
        // detect paste 
        const isPasteCommand = (evt.ctrlKey || evt.metaKey) && evt.key === "v";
        if (isPasteCommand) {
            const clipboard = navigator.clipboard;
            const value = await clipboard.readText().catch(console.warn);
            if (value) {
                const isUrl = value.startsWith("http") || value.startsWith("https") || value.startsWith("blob");
                if (isUrl) {
                    const ctx = { screenposition: new Vector2(this.context.input.mousePosition.x, this.context.input.mousePosition.y) };
                    if (this.testIfIsInDropArea(ctx))
                        this.addFromUrl(value, ctx, false);
                }
            }
        }
    };
    onDrag = (evt) => {
        if (this.context.connection.allowEditing === false)
            return;
        // necessary to get drop event
        evt.preventDefault();
    };
    onDrop = async (evt) => {
        if (this.context.connection.allowEditing === false)
            return;
        if (debug)
            console.log(evt);
        if (!evt?.dataTransfer)
            return;
        // If the event is marked as handled for droplisteners then ignore it
        if (evt["droplistener:handled"])
            return;
        evt.preventDefault();
        const ctx = { screenposition: new Vector2(evt.offsetX, evt.offsetY) };
        if (this.dropArea) {
            const res = this.testIfIsInDropArea(ctx);
            if (res === false)
                return;
        }
        // Don't stop propagation because this will break e.g. the RemoteSkybox drop
        // evt.stopImmediatePropagation();
        // Mark the event handled for droplisteners
        evt["droplistener:handled"] = true;
        const items = evt.dataTransfer.items;
        if (!items)
            return;
        for (const ite in items) {
            const it = items[ite];
            if (it.kind === "file") {
                const file = it.getAsFile();
                if (!file)
                    continue;
                await this.addFiles([file], ctx);
            }
            else if (it.kind === "string" && it.type == "text/plain") {
                it.getAsString(str => {
                    this.addFromUrl(str, ctx, false);
                });
            }
        }
    };
    async addFromUrl(url, ctx, isRemote) {
        if (debug)
            console.log("dropped url", url);
        try {
            if (url.startsWith("https://github.com/")) {
                // make raw.githubusercontent.com url
                const parts = url.split("/");
                const user = parts[3];
                const repo = parts[4];
                const branch = parts[6];
                const path = parts.slice(7).join("/");
                url = `https://raw.githubusercontent.com/${user}/${repo}/${branch}/${path}`;
            }
            else if (url.startsWith("https://polyhaven.com/a")) {
                url = tryResolvePolyhavenAssetUrl(url);
            }
            if (!url)
                return null;
            // Ignore dropped images
            const lowercaseUrl = url.toLowerCase();
            if (lowercaseUrl.endsWith(".hdr") || lowercaseUrl.endsWith(".hdri") || lowercaseUrl.endsWith(".exr") || lowercaseUrl.endsWith(".png") || lowercaseUrl.endsWith(".jpg") || lowercaseUrl.endsWith(".jpeg")) {
                return null;
            }
            const res = await files.addFileFromUrl(new URL(url), this.context);
            if (res) {
                ctx.url = url;
                const obj = this.addObject(res, ctx, isRemote);
                return obj;
            }
        }
        catch (_) {
            console.warn("String is not a valid URL", url);
        }
        return null;
    }
    async addFiles(fileList, ctx) {
        if (debug)
            console.log("Add files", fileList);
        if (!Array.isArray(fileList))
            return;
        if (!fileList.length)
            return;
        for (const file of fileList) {
            if (!file)
                continue;
            if (debug)
                console.log("Register file " + file.name, file);
            const res = await files.addFile(file, this.context);
            this.dispatchEvent(new CustomEvent(DropListenerEvents.FileDropped, { detail: file }));
            if (res)
                this.addObject(res, ctx, false);
        }
    }
    /** Previously added objects */
    _addedObjects = new Array();
    addObject(gltf, ctx, isRemote) {
        if (debug)
            console.log(`Dropped ${this.gameObject.name}`, gltf);
        if (!gltf?.scene) {
            console.warn("No object specified to add to scene", gltf);
            return null;
        }
        for (const prev of this._addedObjects) {
            if (prev.parent === this.gameObject) {
                destroy(prev, true, true);
            }
        }
        this._addedObjects.length = 0;
        const obj = gltf.scene;
        // use attach to ignore the DropListener scale (e.g. if the parent object scale is not uniform)
        this.gameObject.attach(obj);
        obj.position.set(0, 0, 0);
        obj.quaternion.identity();
        this._addedObjects.push(obj);
        if (debug)
            obj.add(new AxesHelper(1));
        const volume = new Box3().setFromCenterAndSize(new Vector3(0, this.fitVolumeSize.y * .5, 0).add(this.gameObject.worldPosition), this.fitVolumeSize);
        if (debug)
            Gizmos.DrawWireBox3(volume, 0x0000ff, 5);
        if (this.fitIntoVolume) {
            fitObjectIntoVolume(obj, volume, {
                position: !this.placeAtHitPosition
            });
        }
        if (this.placeAtHitPosition && ctx && ctx.screenposition) {
            obj.visible = false; // < don't raycast on the placed object
            const rc = this.context.physics.raycast({ screenPoint: this.context.input.convertScreenspaceToRaycastSpace(ctx.screenposition.clone()) });
            obj.visible = true;
            if (rc && rc.length > 0) {
                for (const hit of rc) {
                    const pos = hit.point.clone();
                    if (debug)
                        console.log("Place object at hit", hit);
                    placeOnSurface(obj, pos);
                    break;
                }
            }
        }
        AnimationUtils.assignAnimationsFromFile(gltf, {
            createAnimationComponent: obj => addComponent(obj, Animation)
        });
        this.dispatchEvent(new CustomEvent(DropListenerEvents.ObjectAdded, { detail: gltf }));
        this.onDropped?.invoke({ sender: this, gltf });
        // send network event
        if (!isRemote && ctx.url?.startsWith("http") && this.context.connection.isConnected && obj) {
            const evt = {
                guid: this.guid,
                url: ctx.url,
                point: obj.position.clone(),
            };
            this.context.connection.send("droplistener", evt);
        }
        return obj;
    }
    testIfIsInDropArea(ctx) {
        if (this.dropArea) {
            const screenPoint = this.context.input.convertScreenspaceToRaycastSpace(ctx.screenposition.clone());
            const hits = this.context.physics.raycast({
                targets: [this.dropArea],
                screenPoint,
                recursive: true,
                testObject: obj => {
                    if (this._addedObjects.includes(obj))
                        return false;
                    return true;
                }
            });
            if (!hits.length) {
                if (isDevEnvironment())
                    console.log(`Dropped outside of drop area for DropListener \"${this.name}\".`);
                return false;
            }
        }
        return true;
    }
}
__decorate([
    serializable(Object3D)
], DropListener.prototype, "dropArea", void 0);
__decorate([
    serializable()
], DropListener.prototype, "fitIntoVolume", void 0);
__decorate([
    serializable(Vector3)
], DropListener.prototype, "fitVolumeSize", void 0);
__decorate([
    serializable()
], DropListener.prototype, "placeAtHitPosition", void 0);
__decorate([
    serializable(EventList)
], DropListener.prototype, "onDropped", void 0);
function tryResolvePolyhavenAssetUrl(urlStr) {
    if (!urlStr.startsWith("https://polyhaven.com/"))
        return urlStr;
    // Handle dropping polyhaven image url
    const baseUrl = "https://dl.polyhaven.org/file/ph-assets/Models/gltf/4k/";
    const url = new URL(urlStr);
    const path = url.pathname;
    const name = path.split("/").pop();
    const assetUrl = `${baseUrl}${name}/${name}_4k.gltf`;
    console.log("Resolved polyhaven asset url", urlStr, "→", assetUrl);
    // TODO: need to resolve textures properly
    return assetUrl;
}
//# sourceMappingURL=DropListener.js.map