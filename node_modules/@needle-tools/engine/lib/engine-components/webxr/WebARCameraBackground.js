var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { DoubleSide, Mesh, MeshBasicMaterial, PerspectiveCamera, PlaneGeometry, Scene, ShaderLib, ShaderMaterial, Texture, UniformsUtils, } from "three";
import { serializable } from "../../engine/engine_serialization_decorator.js";
import { getParam } from "../../engine/engine_utils.js";
import { RGBAColor } from "../../engine/js-extensions/index.js";
import { Behaviour } from "../Component.js";
const debug = getParam("debugarcamera");
/**
 * WebARCameraBackground is a component that allows to display the camera feed as a background in an AR session to more easily blend the real world with the virtual world or applying effects to the camera feed.
 */
export class WebARCameraBackground extends Behaviour {
    /** @internal */
    onBeforeXR(_mode, args) {
        args.optionalFeatures = args.optionalFeatures || [];
        args.optionalFeatures.push('camera-access');
        if (debug)
            console.warn("Requesting camera-access");
    }
    /** @internal */
    onEnterXR(_args) {
        if (this.backgroundPlane) {
            this.context.scene.add(this.backgroundPlane);
            this.backgroundPlane.visible = false;
        }
        if (this.backgroundPlane)
            this.context.scene.add(this.backgroundPlane);
        this.context.pre_render_callbacks.push(this.preRender);
    }
    /** @internal */
    onLeaveXR(_args) {
        if (this.backgroundPlane)
            this.backgroundPlane.removeFromParent();
        const i = this.context.pre_render_callbacks.indexOf(this.preRender);
        if (i >= 0)
            this.context.pre_render_callbacks.splice(i, 1);
    }
    /**
     * The tint color of the camera feed
     */
    backgroundTint = new RGBAColor(1, 1, 1, 1);
    get background() {
        return this.backgroundPlane;
    }
    backgroundPlane;
    threeTexture;
    forceTextureInitialization = function () {
        const material = new MeshBasicMaterial();
        const geometry = new PlaneGeometry();
        const scene = new Scene();
        scene.add(new Mesh(geometry, material));
        const camera = new PerspectiveCamera();
        return function forceTextureInitialization(renderer, texture) {
            material.map = texture;
            renderer.render(scene, camera);
            if (debug)
                console.warn("Force texture initialization");
        };
    }();
    /** @internal */
    preRender = () => {
        if (!this || !this.gameObject)
            return;
        const xr = this.context.renderer.xr;
        const frame = xr.getFrame();
        if (frame) {
            // We're generating a new texture here, and force three to initialize it
            // from https://stackoverflow.com/a/55084367 to inject a custom texture into three.js
            if (!this.threeTexture && this.context.renderer) {
                this.threeTexture = new Texture();
                this.forceTextureInitialization(this.context.renderer, this.threeTexture);
            }
            // simple mesh and fullscreen shader to display the camera texture
            // from three: WebGLBackground
            if (this.backgroundPlane === undefined) {
                this.backgroundPlane = makeFullscreenPlane(this.backgroundTint);
            }
            if (this.backgroundPlane.parent !== this.scene)
                this.scene.add(this.backgroundPlane);
            // WebXR Raw Camera Access - 
            // we composite the camera texture into the scene background by rendering it first.
            this.updateFromFrame(frame);
        }
    };
    /** @internal */
    onBeforeRender(frame) {
        this.updateFromFrame(frame);
    }
    updateFromFrame(frame) {
        if (!frame)
            return;
        // If camera feed is not present, then abort and hiden background
        const enabledFeatures = frame.session.enabledFeatures;
        if (enabledFeatures && !enabledFeatures.some(x => x === 'camera-access')) {
            if (this.background) {
                this.background.visible = false;
            }
            return;
        }
        // https://chromium.googlesource.com/chromium/src/+/7c5ac3c0f95b97cf12be95a5c1c0a8ff163246d8/third_party/webxr_test_pages/webxr-samples/proposals/camera-access-barebones.html
        const pose = frame.getViewerPose(this.context.renderer.xr.getReferenceSpace());
        if (pose) {
            for (const view of pose.views) {
                // @ts-ignore
                if ('camera' in view && view.camera) {
                    const xrManager = this.context.renderer.xr;
                    let binding = xrManager.getBinding();
                    // not sure how / why this can be null, but we can recreate it here
                    if (!binding)
                        binding = new XRWebGLBinding(frame.session, this.context.renderer.getContext());
                    if (binding) {
                        let glImage = null;
                        if ('getCameraImage' in binding) {
                            // @ts-ignore
                            glImage = binding.getCameraImage(view.camera);
                            // discussion on exactly this:
                            // https://discourse.threejs.org/t/using-a-webgltexture-as-texture-for-three-js/46245/8
                            // HACK from https://stackoverflow.com/a/55084367 to inject a custom texture into three.js
                            const texProps = this.context.renderer.properties.get(this.threeTexture);
                            texProps.__webglTexture = glImage;
                            if (this.backgroundPlane) {
                                //@ts-ignore
                                this.backgroundPlane.setTexture(this.threeTexture);
                                this.backgroundPlane.visible = true;
                            }
                            else {
                                if (debug)
                                    console.warn("No background plane to set texture on");
                            }
                        }
                    }
                    else {
                        // console.error(view.camera, xrManager)
                    }
                }
                else {
                    // console.error("NO CAMERA IN VIEW")
                }
            }
        }
        else {
            // console.error(this.context.renderer.xr.getReferenceSpace(), frame);
        }
    }
}
__decorate([
    serializable(RGBAColor)
], WebARCameraBackground.prototype, "backgroundTint", void 0);
// TODO tint could be an uniform
const backgroundFragment = /* glsl */ `
uniform sampler2D t2D;

varying vec2 vUv;

void main() {

    vec4 texColor = texture2D( t2D, vUv );
    texColor.w = 1.0;

    // inline sRGB decode
    texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );

    gl_FragColor = texColor * <backgroundTint>;

    #include <tonemapping_fragment>
    #include <colorspace_fragment>
}
`;
// not sure where we want to move this and in which form is best (extends Object3D?)
/**
 * Creates a fullscreen plane with a shader that can be used to display a camera feed or other background.
 */
export function makeFullscreenPlane(tint) {
    const replacementTint = "vec4(" + tint.r.toFixed(3) + "," + tint.g.toFixed(3) + "," + tint.b.toFixed(3) + "," + tint.a.toFixed(3) + ")";
    if (debug)
        console.log(replacementTint);
    const planeMesh = new Mesh(new PlaneGeometry(2, 2), 
    // @ts-ignore
    new ShaderMaterial({
        name: 'BackgroundMaterial',
        uniforms: UniformsUtils.clone(ShaderLib.background.uniforms),
        vertexShader: ShaderLib.background.vertexShader,
        fragmentShader: backgroundFragment.replaceAll("<backgroundTint>", replacementTint),
        side: DoubleSide,
        depthTest: false,
        depthWrite: false,
        fog: false
    }));
    planeMesh.geometry.deleteAttribute('normal');
    // add "map" material property so the renderer can evaluate it like for built-in materials
    Object.defineProperty(planeMesh.material, 'map', {
        get: function () {
            return this.threeTexture;
        }
    });
    // Option 1: add the planeMesh to our scene for rendering.
    // This is useful for applying custom shader effects on the background (instead of using the system composite)
    planeMesh.renderOrder = -10000; // render first
    // planeMesh.layers.disableAll();
    planeMesh.layers.set(2); // ignore raycasts
    planeMesh.frustumCulled = false;
    // should be a class, for now lets just define a method for the weird way the texture needs to be set
    // @ts-ignore
    planeMesh.setTexture = function (texture) {
        planeMesh.material.uniforms.t2D.value = texture;
    };
    return planeMesh;
}
//# sourceMappingURL=WebARCameraBackground.js.map