import { FrameEvent } from "./engine_context.js";
import { ContextEvent } from "./engine_context_registry.js";
import { safeInvoke } from "./engine_generic_utils.js";
const allMethods = new Map();
const _started = new WeakSet();
/** register a function to be called during the Needle Engine frame event at a specific point
 * @param cb the function to call
 * @param evt the event to call the function at
 */
export function registerFrameEventCallback(cb, evt, opts) {
    if (!allMethods.has(evt)) {
        allMethods.set(evt, new Array());
    }
    allMethods.get(evt).push({
        method: cb,
        options: { once: false, ...opts }
    });
}
/**
 * unregister a function to be called during the Needle Engine frame event at a specific point
 */
export function unregisterFrameEventCallback(cb, evt) {
    const methods = allMethods.get(evt);
    if (methods) {
        for (let i = 0; i < methods.length; i++) {
            if (methods[i].method === cb) {
                methods.splice(i, 1);
                return;
            }
        }
    }
}
export function invokeLifecycleFunctions(ctx, evt) {
    // When a context is created, we need to reset the started state
    // Because we want to invoke `onStart` again (even if it's the same context)
    if (evt === ContextEvent.ContextCreated) {
        _started.delete(ctx);
    }
    const methods = allMethods.get(evt);
    if (methods) {
        if (methods.length > 0) {
            const array = methods;
            if (evt === FrameEvent.Start) {
                if (_started.has(ctx)) {
                    return;
                }
                else {
                    _started.add(ctx);
                }
            }
            invoke(ctx, array);
        }
    }
}
const bufferArray = new Array();
function invoke(ctx, methods) {
    bufferArray.length = 0;
    for (let i = 0; i < methods.length; i++) {
        bufferArray.push(methods[i]);
    }
    for (let i = 0; i < bufferArray.length; i++) {
        const entry = bufferArray[i];
        safeInvoke(entry.method, ctx);
        // Remove the method if it's a one time call
        if (entry.options?.once) {
            for (let j = 0; j < methods.length; j++) {
                if (methods[j] === entry) {
                    methods.splice(j, 1);
                    break;
                }
            }
        }
    }
}
//# sourceMappingURL=engine_lifecycle_functions_internal.js.map