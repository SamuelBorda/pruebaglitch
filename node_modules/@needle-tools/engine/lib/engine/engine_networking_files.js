import { BoxGeometry, BoxHelper, Mesh, MeshBasicMaterial } from "three";
import { getLoader } from "../engine/engine_gltf.js";
import { generateSeed, InstantiateIdProvider } from "../engine/engine_networking_instantiate.js";
import * as web from "../engine/engine_web_api.js";
import { ContextEvent, ContextRegistry } from "./engine_context_registry.js";
import { findByGuid } from "./engine_gameobject.js";
import * as def from "./engine_networking_files_default_components.js";
export var File_Event;
(function (File_Event) {
    File_Event["File_Spawned"] = "file-spawned";
})(File_Event || (File_Event = {}));
export class FileSpawnModel {
    guid;
    file_name;
    file_hash;
    file_size;
    position;
    seed;
    sender;
    serverUrl;
    parentGuid;
    boundsSize;
    constructor(connectionId, seed, guid, name, hash, size, position, serverUrl) {
        this.seed = seed;
        this.guid = guid;
        this.file_name = name;
        this.file_hash = hash;
        this.file_size = size;
        this.position = position;
        this.sender = connectionId;
        this.serverUrl = serverUrl;
    }
}
export async function addFile(file, context, backendUrl) {
    const name = file.name;
    if (name.endsWith(".gltf") || name.endsWith(".glb") || file.type === "model/gltf+json" || file.type === "model/gltf-binary") {
        return new Promise((resolve, _reject) => {
            const reader = new FileReader();
            reader.readAsArrayBuffer(file);
            reader.onloadend = async (_ev) => {
                const content = reader.result;
                // first load it locally
                const seed = generateSeed();
                const prov = new InstantiateIdProvider(seed);
                const gltf = await getLoader().parseSync(context, content, file.name, prov);
                if (gltf && gltf.scene) {
                    const obj = gltf.scene;
                    // if we dont have a guid yet (because components guids are actually created in a callback a bit later)
                    // we just use the same seed and generate a guid for the root only
                    // this should be the exact same guid the instantiate call will produce
                    if (!obj.guid) {
                        const prov = new InstantiateIdProvider(seed);
                        obj.guid = prov.generateUUID();
                    }
                    if (backendUrl)
                        handleUpload(context.connection, file, seed, obj, backendUrl);
                    def.onDynamicObjectAdded(obj, prov, gltf);
                    resolve(gltf);
                }
            };
        });
    }
    else {
        console.warn("Unsupported file type: " + name, file);
    }
    return null;
}
export async function addFileFromUrl(url, context) {
    return new Promise(async (resolve, _reject) => {
        const seed = generateSeed();
        const prov = new InstantiateIdProvider(seed);
        const urlStr = url.toString();
        const gltf = await getLoader().loadSync(context, urlStr, urlStr, prov);
        if (gltf && gltf.scene) {
            const obj = gltf.scene;
            // handleUpload(context.connection, file, seed, obj); // TODO needs to upload the URL only and store that
            def.onDynamicObjectAdded(obj, prov, gltf);
            resolve(gltf);
        }
        else {
            console.warn("Unsupported file type: " + url.toString());
        }
    });
}
ContextRegistry.registerCallback(ContextEvent.ContextCreated, evt => {
    beginListenFileSpawn(evt.context);
});
export function beginListenFileSpawn(context) {
    context.connection.beginListen(File_Event.File_Spawned, async (evt) => {
        if (evt.sender !== context.connection.connectionId) {
            console.log("received file event", evt);
            addPreview(evt, context);
            let bin = null;
            try {
                bin = await web.download_file(evt.file_name, evt.file_hash, evt.file_size, evt.serverUrl);
            }
            finally {
                removePreview(evt, context);
            }
            if (bin) {
                const prov = new InstantiateIdProvider(evt.seed);
                const gltf = await getLoader().parseSync(context, bin, evt.file_name, prov);
                if (gltf && gltf.scene) {
                    const obj = gltf.scene;
                    def.onDynamicObjectAdded(obj, prov, gltf);
                    // if we process new scripts immediately references that rely on guids are not properly resolved
                    // for example duplicatable "object" reference will not be found anymore because guid has changed
                    // processNewScripts(context);
                    // add object to proper parent
                    if (evt.parentGuid) {
                        const parent = findByGuid(evt.parentGuid, context.scene);
                        if (parent && "add" in parent)
                            parent.add(obj);
                    }
                    if (!obj.parent)
                        context.scene.add(obj);
                    if (evt.position !== null) {
                        obj.position.copy(evt.position);
                    }
                }
            }
            else
                console.error("download didnt return file");
        }
    });
}
async function handleUpload(connection, file, seed, obj, backendUrl) {
    if (!connection.connectionId) {
        console.error("Can not upload file - no connection id");
        return;
    }
    if (!obj.guid) {
        console.error("Can not upload file - no guid", obj, obj.guid);
        return;
    }
    // then try uploading it
    const upload_result = await web.upload_file(file, backendUrl);
    if (!upload_result) {
        return;
    }
    if (!upload_result.filename) {
        console.error("Can not send upload event - no filename", file.name);
        return;
    }
    if (!upload_result.hash) {
        console.error("Can not send upload event - no hash", file.name);
        return;
    }
    const model = new FileSpawnModel(connection.connectionId, seed, obj.guid, upload_result.filename, upload_result.hash, file.size, obj.position, upload_result.url ?? backendUrl);
    if (obj.parent)
        model.parentGuid = obj.parent["guid"];
    connection.send(File_Event.File_Spawned, model);
}
const previews = {};
function addPreview(evt, context) {
    const sphere = new BoxGeometry();
    const object = new Mesh(sphere, new MeshBasicMaterial({ color: 0x00ff00 }));
    const box = new BoxHelper(object, 0x555555);
    previews[evt.guid] = box;
    context.scene.add(box);
    if (evt.parentGuid) {
        const parent = findByGuid(evt.parentGuid, context.scene);
        if (parent)
            parent.add(box);
    }
    if (evt.position)
        box.position.copy(evt.position);
}
function removePreview(evt, _context) {
    const guid = evt.guid;
    const existing = previews[guid];
    if (existing) {
        delete previews[guid];
        existing.removeFromParent();
    }
}
//# sourceMappingURL=engine_networking_files.js.map