import { getParam } from "./engine_utils.js";
const debug = getParam("debugfileformat");
/**
 * Tries to determine the file type of a file from its URL
 * This method does perform a range request to the server to get the first few bytes of the file
 * If the file type can not be determined it will return "unknown"
 * @param url The URL of the file
 * @param lazy If true the file type will be determined by the file extension first - if the file extension is not known it will then check the header
 * @example
 * ```typescript
 * const url = "https://example.com/model.glb";
 * const fileType = await tryDetermineFileTypeFromURL(url);
 * console.log(fileType); // "glb"
 */
export async function tryDetermineFileTypeFromURL(url, lazy = true) {
    if (lazy) {
        // We want to save on requests so we first check the file extension if there's any
        // In some scenarios we might not have one (e.g. if we're dealing with blob: files or if the URL doesn't contain the filename)
        // In that case we need to check the header
        const _url = url;
        // if (!_url.startsWith("http") && !url.startsWith("blob:")) {
        //     // _url = "file:" + url;
        // }
        const urlobj = new URL(_url, globalThis.location.origin);
        let ext = null;
        const query = urlobj.searchParams.get("filetype");
        if (query)
            ext = query.toUpperCase();
        if (!ext?.length) {
            ext = urlobj.pathname.split(".").pop()?.toUpperCase();
        }
        switch (ext) {
            case "GLTF":
                return "gltf";
            case "VRM":
                return "vrm";
            case "GLB":
                return "glb";
            case "FBX":
                return "fbx";
            case "USD":
                return "usd";
            case "USDA":
                return "usda";
            case "USDZ":
                return "usdz";
        }
    }
    // If the URL doesnt contain a filetype we need to check the header
    // This is the case for example if we load a file from a data url
    const header = await fetch(url, {
        method: "GET",
        headers: {
            "range": "bytes=0-32"
        }
    }).catch(_ => {
        return null;
    });
    if (header?.ok) {
        const data = await header.arrayBuffer();
        const res = tryDetermineFileTypeFromBinary(data);
        if (debug)
            console.log("Determined file type from header: " + res);
        return res;
    }
    return "unknown";
}
/** Attempts to determine the file type of a binary file by looking at the first few bytes of the file.
 * @hidden
 */
export function tryDetermineFileTypeFromBinary(data) {
    if (data.byteLength < 4) {
        return "unknown";
    }
    const bytes = new Uint8Array(data);
    if (debug) {
        console.warn("Trying to determine file type from binary data\n", "\"" + new TextDecoder().decode(data) + "\"\n", bytes);
    }
    // GLTF or GLB
    if (bytes[0] == 103 && bytes[1] == 108 && bytes[2] == 84 && bytes[3] == 70) {
        return "glb";
    }
    // USDZ
    if (bytes[0] == 80 && bytes[1] == 75 && bytes[2] == 3 && bytes[3] == 4) {
        return "usdz";
    }
    // USD
    if (bytes[0] == 80 && bytes[1] == 88 && bytes[2] == 82 && bytes[3] == 45 && bytes[4] == 85 && bytes[5] == 83 && bytes[6] == 68 && bytes[7] == 67) {
        return "usd";
    }
    // USDA: check if the file starts with #usda
    else if (bytes[0] == 35 && bytes[1] == 117 && bytes[2] == 115 && bytes[3] == 100 && bytes[4] == 97) {
        return "usda";
    }
    // FBX
    if (bytes[0] == 75 && bytes[1] == 97 && bytes[2] == 121 && bytes[3] == 100 && bytes[4] == 97 && bytes[5] == 114 && bytes[6] == 97 && bytes[7] == 32) {
        return "fbx";
    }
    // OBJ - in this case exported from blender it starts with "# Blender" - we only check the first 10 bytes, technically it could still be a different file so we should do this check at the end
    else if (bytes[0] == 35 && bytes[1] == 32 && bytes[2] == 66 && bytes[3] == 108 && bytes[4] == 101 && bytes[5] == 110 && bytes[6] == 100 && bytes[7] == 101 && bytes[8] == 114 && bytes[9] == 32) {
        // const text = new TextDecoder().decode(data.slice(0, 9));
        return "obj";
    }
    // const text = new TextDecoder().decode(data);
    // if (text.startsWith("Kaydara FBX")) {
    //     return "fbx";
    // }
    // else if (text.startsWith("glTF")) {
    //     return "gltf";
    // }
    return "unknown";
}
//# sourceMappingURL=engine_utils_format.js.map