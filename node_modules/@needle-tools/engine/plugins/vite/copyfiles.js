
import { resolve, join, isAbsolute } from 'path'
import { existsSync, statSync, mkdirSync, readdirSync, copyFileSync, mkdir } from 'fs';
import { builtAssetsDirectory, tryLoadProjectConfig } from './config.js';


/** copy files on build from assets to dist 
 * @param {import('../types').userSettings} userSettings
 */
export const needleCopyFiles = (command, config, userSettings) => {

    if (config?.noCopy === true || userSettings?.noCopy === true) {
        return;
    }

    return {
        name: 'needle-copy-files',
        buildStart() {
            return run(false, config);
        },
        closeBundle() {
            return run(true, config);
        },
    }
}

async function run(isBuild, config) {
    const copyIncludesFromEngine = config?.copyIncludesFromEngine ?? true;

    const baseDir = process.cwd();
    const pluginName = "needle-copy-files";

    let assetsDirName = "assets";
    let outdirName = "dist";

    const needleConfig = tryLoadProjectConfig();
    if (needleConfig) {
        assetsDirName = needleConfig.assetsDirectory;
        while (assetsDirName.startsWith('/')) assetsDirName = assetsDirName.substring(1);

        if (needleConfig.buildDirectory)
            outdirName = needleConfig.buildDirectory;
    }

    if (copyIncludesFromEngine !== false) {
        // copy include from engine
        const engineIncludeDir = resolve(baseDir, 'node_modules', '@needle-tools', 'engine', 'src', 'include');
        if (existsSync(engineIncludeDir)) {
            console.log(`[${pluginName}] - Copy engine include to ${baseDir}/include`)
            const projectIncludeDir = resolve(baseDir, 'include');
            copyRecursiveSync(engineIncludeDir, projectIncludeDir);
        }
    }

    if (isBuild) {
        const outDir = resolve(baseDir, outdirName);
        if (!existsSync(outDir)) {
            mkdirSync(outDir);
        }

        // copy a list of files or directories declared in build.copy = [] in the needle.config.json
        /*
        "build": {
            "copy": ["myFolder", "myFile.txt"]
        }
        */
        if (needleConfig?.build?.copy) {
            const arr = needleConfig.build.copy;
            for (let i = 0; i < arr.length; i++) {
                const entry = arr[i];
                if (Array.isArray(entry)) {
                    console.log("WARN: build.copy can only contain string paths to copy to. Found array instead.");
                    continue;
                }
                const src = resolve(baseDir, entry);
                const dest = resolvePath(outDir, entry);
                if (existsSync(src)) {
                    console.log(`[${pluginName}] - Copy ${entry} to ${outdirName}/${entry}`)
                    copyRecursiveSync(src, dest);
                }
            }
        }

        // copy assets dir
        const assetsDir = resolve(baseDir, assetsDirName);
        if (existsSync(assetsDir)) {
            console.log(`[${pluginName}] - Copy assets to ${outdirName}/${builtAssetsDirectory()}`)
            const targetDir = resolve(outDir, 'assets');
            copyRecursiveSync(assetsDir, targetDir);
        }
        else console.log(`WARN: No assets directory found. Skipping copy of ${assetsDirName} resolved to ${assetsDir}`)
        // copy include dir
        const includeDir = resolve(baseDir, 'include');
        if (existsSync(includeDir)) {
            console.log(`[${pluginName}] - Copy include to ${outdirName}/include`)
            const targetDir = resolve(outDir, 'include');
            copyRecursiveSync(includeDir, targetDir);
        }
    }
}

/** resolves relative or absolute paths to a path inside the out directory
 * for example D:/myFile.txt would resolve to outDir/myFile.txt
 * wherereas "some/relative/path" would become outDir/some/relative/path
 */
function resolvePath(outDir, pathValue) {
    if (isAbsolute(pathValue)) {
        var exists = existsSync(pathValue);
        if (!exists) return null;
        var stats = exists && statSync(pathValue);
        if (stats.isDirectory()) {
            const dirName = pathValue.replaceAll('\\', '/').split('/').pop();
            return resolve(outDir, dirName);
        }
        const fileName = pathValue.replaceAll('\\', '/').split('/').pop();
        return resolve(outDir, fileName);
    }
    return resolve(outDir, pathValue);
}

function copyRecursiveSync(src, dest) {
    if (dest === null) {
        console.log(`[${pluginName}] - Copy ${src} to ${dest} - dest is null`)
        return;
    }
    var exists = existsSync(src);
    var stats = exists && statSync(src);
    var isDirectory = exists && stats.isDirectory();
    if (isDirectory) {
        if (!existsSync(dest))
            mkdirSync(dest, { recursive: true });
        readdirSync(src).forEach(function (childItemName) {
            copyRecursiveSync(join(src, childItemName), join(dest, childItemName));
        });
    } else {
        copyFileSync(src, dest);
    }
};