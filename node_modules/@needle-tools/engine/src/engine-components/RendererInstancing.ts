import { BatchedMesh, BufferAttribute, BufferGeometry, Color, InstancedMesh, InterleavedBuffer, InterleavedBufferAttribute, Material, Matrix4, Mesh, MeshBasicMaterial, MeshStandardMaterial, Object3D, RawShaderMaterial, StaticDrawUsage, Texture, Vector3 } from "three";

import { isDevEnvironment, showBalloonError } from "../engine/debug/index.js";
import { $instancingAutoUpdateBounds, $instancingRenderer, NEED_UPDATE_INSTANCE_KEY } from "../engine/engine_instancing.js";
import { Context } from "../engine/engine_setup.js";
import { getParam, makeIdFromRandomWords } from "../engine/engine_utils.js";
import { NEEDLE_progressive } from "../engine/extensions/index.js";
import { GameObject } from "./Component.js";
import type { Renderer } from "./Renderer.js";

const debugInstancing = getParam("debuginstancing");

declare class InstancingSetupArgs {
    rend: Renderer;
    foundMeshes: number;
    useMatrixWorldAutoUpdate: boolean;
};

export class InstancingHandler {
    static readonly instance: InstancingHandler = new InstancingHandler();

    public objs: InstancedMeshRenderer[] = [];

    public setup(renderer: Renderer, obj: Object3D, context: Context, handlesArray: InstanceHandle[] | null, args: InstancingSetupArgs, level: number = 0)
        : InstanceHandle[] | null {

        // make sure setting casting settings are applied so when we add the mesh to the InstancedMesh we can ask for the correct cast shadow setting
        renderer.applySettings(obj);
        const res = this.tryCreateOrAddInstance(obj, context, args);
        if (res) {
            NEEDLE_progressive.assignTextureLOD(res.renderer.material, 0);
            // renderer.loadProgressiveMeshes(res.instancer.mesh, 0);
            if (handlesArray === null) handlesArray = [];
            handlesArray.push(res);
        }

        else if (level <= 0 && obj.type !== "Mesh") {
            const nextLevel = level + 1;
            for (const ch of obj.children) {
                handlesArray = this.setup(renderer, ch, context, handlesArray, args, nextLevel);
            }
        }

        if (level === 0) {
            // For multi material objects we only want to track the root object's matrix
            if (args.useMatrixWorldAutoUpdate && handlesArray && handlesArray.length >= 0) {
                this.autoUpdateInstanceMatrix(obj);
            }
        }

        return handlesArray;
    }

    private tryCreateOrAddInstance(obj: Object3D, context: Context, args: InstancingSetupArgs): InstanceHandle | null {
        if (obj.type === "Mesh") {
            const index = args.foundMeshes;
            args.foundMeshes += 1;
            if (!args.rend.enableInstancing) return null;
            if (args.rend.enableInstancing === true) {
                // instancing is enabled globally
                // continue....
            }
            else {
                if (index >= args.rend.enableInstancing.length) {
                    if (debugInstancing) console.error("Something is wrong with instance setup", obj, args.rend.enableInstancing, index);
                    return null;
                }
                if (!args.rend.enableInstancing[index]) {
                    // instancing is disabled
                    // console.log("Instancing is disabled", obj);
                    return null;
                }
            }
            // instancing is enabled:
            const mesh = obj as Mesh;
            // const geo = mesh.geometry as BufferGeometry;
            const mat = mesh.material as Material;

            for (const i of this.objs) {
                if (!i.canAdd(mesh.geometry, mat)) continue;
                const handle = i.addInstance(mesh);
                return handle;
            }
            const maxInstances = 16;
            let name = obj.name;
            if (!name?.length) name = makeIdFromRandomWords();
            const i = new InstancedMeshRenderer(name, mesh.geometry, mat, maxInstances, context);
            this.objs.push(i);
            const handle = i.addInstance(mesh);
            return handle;
        }
        return null;
    }

    private autoUpdateInstanceMatrix(obj: Object3D) {
        const original = obj.matrixWorld["multiplyMatrices"].bind(obj.matrixWorld);
        const previousMatrix: Matrix4 = obj.matrixWorld.clone();
        const matrixChangeWrapper = (a: Matrix4, b: Matrix4) => {
            const newMatrixWorld = original(a, b);
            if (obj[NEED_UPDATE_INSTANCE_KEY] || previousMatrix.equals(newMatrixWorld) === false) {
                previousMatrix.copy(newMatrixWorld)
                obj[NEED_UPDATE_INSTANCE_KEY] = true;
            }
            return newMatrixWorld;
        };
        obj.matrixWorld["multiplyMatrices"] = matrixChangeWrapper;
        // wrap matrixWorldNeedsUpdate
        // let originalMatrixWorldNeedsUpdate = obj.matrixWorldNeedsUpdate;
        // Object.defineProperty(obj, "matrixWorldNeedsUpdate", {
        //     get: () => {
        //         return originalMatrixWorldNeedsUpdate;
        //     },
        //     set: (value: boolean) => {
        //         if(value) console.warn("SET MATRIX WORLD NEEDS UPDATE");
        //         originalMatrixWorldNeedsUpdate = value;
        //     }
        // });
    }
}

export class InstanceHandle {

    static readonly all: InstanceHandle[] = [];

    /** The name of the object */
    get name(): string {
        return this.object.name;
    }
    get isActive() {
        return this.__instanceIndex >= 0;
    }
    get vertexCount() {
        return this.object.geometry.attributes.position.count;
    }
    get maxVertexCount() {
        return this.meshInformation.vertexCount;
    }
    get reservedVertexCount() {
        return this.__reservedVertexRange;
    }
    get indexCount() {
        return this.object.geometry.index ? this.object.geometry.index.count : 0;
    }
    get maxIndexCount() {
        return this.meshInformation.indexCount;
    }
    get reservedIndexCount() {
        return this.__reservedIndexRange;
    }

    /** The object that is being instanced */
    readonly object: Mesh;

    /** The instancer/BatchedMesh that is rendering this object*/
    readonly renderer: InstancedMeshRenderer;

    /** @internal */
    __instanceIndex: number = -1;
    /** @internal */
    __reservedVertexRange: number = 0;
    /** @internal */
    __reservedIndexRange: number = 0;

    /** The mesh information of the object */
    readonly meshInformation: MeshInformation;

    constructor(originalObject: Mesh, instancer: InstancedMeshRenderer) {
        this.__instanceIndex = -1;
        this.object = originalObject;
        this.renderer = instancer;
        originalObject[$instancingRenderer] = instancer;
        this.meshInformation = getMeshInformation(originalObject.geometry);
        InstanceHandle.all.push(this);
    }

    /** Updates the matrix from the rendered object. Will also call updateWorldMatrix internally */
    updateInstanceMatrix(updateChildren: boolean = false, updateMatrix: boolean = true) {
        if (this.__instanceIndex < 0) return;
        if (updateMatrix) this.object.updateWorldMatrix(true, updateChildren);
        this.renderer.updateInstance(this.object.matrixWorld, this.__instanceIndex);
    }
    /** Updates the matrix of the instance */
    setMatrix(matrix: Matrix4) {
        if (this.__instanceIndex < 0) return;
        this.renderer.updateInstance(matrix, this.__instanceIndex);
    }

    /** Can be used to change the geometry of this instance */
    setGeometry(geo: BufferGeometry) {
        if (this.__instanceIndex < 0) return false;
        if (this.vertexCount > this.__reservedVertexRange) {
            console.error(`Cannot update geometry, reserved range is too small: ${this.__reservedVertexRange} < ${this.vertexCount} vertices for ${this.name}`);
            return false;
        }
        if (this.indexCount > this.__reservedIndexRange) {
            console.error(`Cannot update geometry, reserved range is too small: ${this.__reservedIndexRange} < ${this.indexCount} indices for ${this.name}`);
            return false;
        }
        return this.renderer.updateGeometry(geo, this.__instanceIndex);
    }

    /** Adds this object to the instancing renderer (effectively activating instancing) */
    add() {
        if (this.__instanceIndex >= 0) return;
        this.renderer.add(this);
        GameObject.markAsInstancedRendered(this.object, true);
    }

    /** Removes this object from the instancing renderer */
    remove(delete_: boolean) {
        if (this.__instanceIndex < 0) return;
        this.renderer.remove(this, delete_);
        GameObject.markAsInstancedRendered(this.object, false);
        if (delete_) {
            const i = InstanceHandle.all.indexOf(this);
            if (i >= 0) {
                InstanceHandle.all.splice(i, 1);
            }
        }
    }
}

class InstancedMeshRenderer {
    /** The three instanced mesh
     * @link https://threejs.org/docs/#api/en/objects/InstancedMesh
     */
    get mesh() {
        return this.inst;
    }
    get visible(): boolean {
        return this.inst.visible;
    }
    set visible(val: boolean) {
        this.inst.visible = val;
    }
    get castShadow(): boolean {
        return this.inst.castShadow;
    }
    set castShadow(val: boolean) {
        this.inst.castShadow = val;
    }
    set receiveShadow(val: boolean) {
        this.inst.receiveShadow = val;
    }

    /** If true, the instancer is allowed to grow when the max instance count is reached */
    allowResize: boolean = true;

    /** Update the bounding box and sphere of the instanced mesh 
     * @param box If true, update the bounding box
     * @param sphere If true, update the bounding sphere
    */
    updateBounds(box: boolean = true, sphere: boolean = true) {
        this._needUpdateBounds = false;
        if (box)
            this.inst.computeBoundingBox();
        if (sphere)
            this.inst.computeBoundingSphere();
    }

    /** The name of the instancer */
    name: string = "";

    /** The added geometry */
    readonly geometry: BufferGeometry;

    /** The material used for the instanced mesh */
    readonly material: Material;

    /** The current number of instances */
    get count(): number { return this._currentInstanceCount; }

    private context: Context;
    private inst: BatchedMesh;
    private handles: (InstanceHandle | null)[] = [];
    private maxInstanceCount: number;

    private _currentInstanceCount = 0;
    private _currentVertexCount = 0;
    private _currentIndexCount = 0;

    private _maxVertexCount: number;
    private _maxIndexCount: number;

    private static nullMatrix: Matrix4 = new Matrix4();

    /** Check if the geometry can be added to this instancer
     * @param geometry The geometry to check
     * @param material The material of the geometry
     * @returns true if the geometry can be added
     */
    canAdd(geometry: BufferGeometry, material: Material): boolean {

        if (this._maxVertexCount > 10_000_000) return false;

        // The material instance must match
        // perhaps at some point later we *could* check if it's the same shader and properties but this would be risky
        if (material !== this.material) return false;

        // if(this.geometry !== _geometry) return false;

        // console.log(geometry.name, geometry.uuid);

        // if (!this.validateGeometry(geometry)) return false;

        // const validationMethod = this.inst["_validateGeometry"];
        // if (!validationMethod) throw new Error("InstancedMesh does not have a _validateGeometry method");
        // try {
        //     validationMethod.call(this.inst, _geometry);
        // }
        // catch (err) {
        //     // console.error(err);
        //     return false;
        // }

        const hasSpace = !this.mustGrow(geometry);
        if (hasSpace) return true;
        if (this.allowResize) return true;

        return false;
    }

    private _needUpdateBounds: boolean = false;
    private _debugMaterial: MeshStandardMaterial | null = null;

    constructor(name: string, geo: BufferGeometry, material: Material, initialMaxCount: number, context: Context) {
        this.name = name;
        this.geometry = geo;
        this.material = material;
        this.context = context;
        this.maxInstanceCount = Math.max(2, initialMaxCount);
        if (debugInstancing) {
            this._debugMaterial = createDebugMaterial();
        }
        const estimate = this.tryEstimateVertexCountSize(this.maxInstanceCount, [geo], initialMaxCount);
        this._maxVertexCount = estimate.vertexCount;
        this._maxIndexCount = estimate.indexCount;
        this.inst = new BatchedMesh(this.maxInstanceCount, this._maxVertexCount, this._maxIndexCount, this._debugMaterial ?? this.material);
        // this.inst = new InstancedMesh(geo, material, count);
        this.inst[$instancingAutoUpdateBounds] = true;
        // this.inst.count = 0;
        this.inst.visible = true;
        this.context.scene.add(this.inst);

        // Not handled by RawShaderMaterial, so we need to set the define explicitly.
        // Edge case: theoretically some users of the material could use it in an
        // instanced fashion, and some others not. In that case, the material would not
        // be able to be shared between the two use cases. We could probably add a
        // onBeforeRender call for the InstancedMesh and set the define there.
        // Same would apply if we support skinning - 
        // there we would have to split instanced batches so that the ones using skinning
        // are all in the same batch.
        if (material instanceof RawShaderMaterial) {
            material.defines["USE_INSTANCING"] = true;
            material.needsUpdate = true;
        }

        context.pre_render_callbacks.push(this.onBeforeRender);
        context.post_render_callbacks.push(this.onAfterRender);

        if (debugInstancing) {
            console.log(`Instanced renderer created with ${this.maxInstanceCount} instances, ${this._maxVertexCount} max vertices and ${this._maxIndexCount} max indices for \"${name}\"`)
        }
    }

    dispose() {
        if (debugInstancing) console.warn("Dispose instanced renderer", this.name);
        this.context.scene.remove(this.inst);
        this.inst.dispose();
        this.inst = null as any;
        this.handles = [];
    }

    addInstance(obj: Mesh): InstanceHandle | null {

        const handle = new InstanceHandle(obj, this);

        if (obj.castShadow === true && this.inst.castShadow === false) {
            this.inst.castShadow = true;
        }
        if (obj.receiveShadow === true && this.inst.receiveShadow === false) {
            this.inst.receiveShadow = true;
        }

        try {
            this.add(handle);
        }
        catch (e) {
            console.error("Failed adding mesh to instancing\n", e);
            if (isDevEnvironment()) showBalloonError("Failed instancing mesh. See the browser console for details.");
            return null;
        }

        return handle;
    }


    add(handle: InstanceHandle) {
        const geo = handle.object.geometry as BufferGeometry;

        if (!this.validateGeometry(geo)) {
            if (debugInstancing) console.error("Cannot add instance, invalid geometry", this.name, geo);
            return;
        }

        if (this.mustGrow(geo)) {
            if (this.allowResize) {
                this.grow(geo);
            }
            else {
                console.error("Cannot add instance, max count reached", this.name, this.count, this.maxInstanceCount);
                return;
            }
        }

        handle.object.updateWorldMatrix(true, true);
        this.addGeometry(handle);
        this.handles[handle.__instanceIndex] = handle;
        this._currentInstanceCount += 1;

        this.markNeedsUpdate();

        if (this._currentInstanceCount > 0)
            this.inst.visible = true;
    }

    remove(handle: InstanceHandle, delete_: boolean) {
        if (!handle) return;
        if (handle.__instanceIndex < 0 || this.handles[handle.__instanceIndex] != handle || this._currentInstanceCount <= 0) {
            return;
        }

        this.removeGeometry(handle, delete_);
        this.handles[handle.__instanceIndex] = null;
        handle.__instanceIndex = -1;

        if (this._currentInstanceCount > 0) {
            this._currentInstanceCount -= 1;
        }

        if (this._currentInstanceCount <= 0)
            this.inst.visible = false;

        this.markNeedsUpdate();
    }

    updateInstance(mat: Matrix4, index: number) {
        this.inst.setMatrixAt(index, mat);
        this.markNeedsUpdate();
    }

    updateGeometry(geo: BufferGeometry, index: number) {
        if (!this.validateGeometry(geo)) {
            return false;
        }
        if (this.mustGrow()) {
            this.grow(geo);
        }
        if (debugInstancing) console.debug("UPDATE MESH", index, geo.name, getMeshInformation(geo), geo.attributes.position.count, geo.index ? geo.index.count : 0);
        this.inst.setGeometryAt(index, geo);
        this.markNeedsUpdate();
        return true;
    }

    private onBeforeRender = () => {
        // ensure the instanced mesh is rendered / has correct layers
        this.inst.layers.enableAll();

        if (this._needUpdateBounds && this.inst[$instancingAutoUpdateBounds] === true) {
            if (debugInstancing) console.log("Update instancing bounds", this.name, this.inst.matrixWorldNeedsUpdate);
            this.updateBounds();
        }
    }

    private onAfterRender = () => {
        // hide the instanced mesh again when its not being rendered (for raycasting we still use the original object)
        this.inst.layers.disableAll();
    }

    private validateGeometry(_geometry: BufferGeometry): boolean {
        const batchGeometry = this.geometry;

        // for (const attributeName in batchGeometry.attributes) {
        //     if (attributeName === "batchId") {
        //         continue;
        //     }
        //     if (!geometry.hasAttribute(attributeName)) {
        //         // geometry.setAttribute(attributeName, batchGeometry.getAttribute(attributeName).clone());
        //         return false;
        //         // throw new Error(`BatchedMesh: Added geometry missing "${attributeName}". All geometries must have consistent attributes.`);
        //     }
        //     // const srcAttribute = geometry.getAttribute(attributeName);
        //     // const dstAttribute = batchGeometry.getAttribute(attributeName);
        //     // if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {
        //     //     if (debugInstancing) throw new Error('BatchedMesh: All attributes must have a consistent itemSize and normalized value.');
        //     //     return false;
        //     // }
        // }
        return true;
    }

    private markNeedsUpdate() {
        this._needUpdateBounds = true;
        // this.inst.instanceMatrix.needsUpdate = true;
    }

    /**
     * @param geo The geometry to add (if none is provided it means the geometry is already added and just updated)
     */
    private mustGrow(geo?: BufferGeometry): boolean {
        if (this.count >= this.maxInstanceCount) return true;
        if (!geo) return false;
        const meshInfo = getMeshInformation(geo);
        const newVertexCount = meshInfo.vertexCount;
        const newIndexCount = meshInfo.indexCount;
        return this._currentVertexCount + newVertexCount > this._maxVertexCount || this._currentIndexCount + newIndexCount > this._maxIndexCount;
    }

    private grow(geometry: BufferGeometry) {
        const newSize = this.maxInstanceCount * 2;

        // create a new BatchedMesh instance
        const estimatedSpace = this.tryEstimateVertexCountSize(newSize, [geometry]);// geometry.attributes.position.count;
        // const indices = geometry.index ? geometry.index.count : 0;
        const newMaxVertexCount = Math.max(this._maxVertexCount, estimatedSpace.vertexCount);
        const newMaxIndexCount = Math.max(this._maxIndexCount, estimatedSpace.indexCount, this._maxVertexCount * 2);

        if (debugInstancing) {
            const geometryInfo = getMeshInformation(geometry);
            console.warn(`Growing batched mesh for \"${this.name}/${geometry.name}\" ${geometryInfo.vertexCount} vertices, ${geometryInfo.indexCount} indices\nMax count ${this.maxInstanceCount} → ${newSize}\nMax vertex count ${this._maxVertexCount} -> ${newMaxVertexCount}\nMax index count ${this._maxIndexCount} -> ${newMaxIndexCount}`);
            this._debugMaterial = createDebugMaterial();
        }

        this._maxVertexCount = newMaxVertexCount;
        this._maxIndexCount = newMaxIndexCount;
        const newInst = new BatchedMesh(newSize, this._maxVertexCount, this._maxIndexCount, this._debugMaterial ?? this.material);
        newInst.layers = this.inst.layers;
        newInst.castShadow = this.inst.castShadow;
        newInst.receiveShadow = this.inst.receiveShadow;
        newInst.visible = this.inst.visible;
        newInst[$instancingAutoUpdateBounds] = this.inst[$instancingAutoUpdateBounds];
        newInst.matrixAutoUpdate = this.inst.matrixAutoUpdate;
        newInst.matrixWorldNeedsUpdate = this.inst.matrixWorldNeedsUpdate;
        newInst.matrixAutoUpdate = this.inst.matrixAutoUpdate;
        newInst.matrixWorld.copy(this.inst.matrixWorld);
        newInst.matrix.copy(this.inst.matrix);

        // dispose the old batched mesh
        this.inst.dispose();
        this.inst.removeFromParent();

        this.inst = newInst;
        this.maxInstanceCount = newSize;

        // add current instances to new instanced mesh
        for (const handle of this.handles) {
            if (handle && handle.__instanceIndex >= 0) {
                this.addGeometry(handle);
            }
        }

        this.context.scene.add(newInst);
    }

    private tryEstimateVertexCountSize(newMaxInstances: number, _newGeometries?: BufferGeometry[], newGeometriesFactor: number = 1): MeshInformation {
        /** Used geometries and how many instances use them  */
        const usedGeometries = new Map<BufferGeometry, MeshInformation & { count: number }>();
        for (const handle of this.handles) {
            if (handle && handle.__instanceIndex >= 0) {
                if (!usedGeometries.has(handle.object.geometry as BufferGeometry)) {
                    const meshinfo = { count: 1, ...getMeshInformation(handle.object.geometry as BufferGeometry) };
                    usedGeometries.set(handle.object.geometry as BufferGeometry, meshinfo);
                }
                else {
                    const entry = usedGeometries.get(handle.object.geometry as BufferGeometry)!;
                    entry.count += 1;
                }

            }
        }

        // then calculate the total vertex count
        let totalVertices = 0;
        let totalIndices = 0;
        // let maxVertices = 0;
        for (const [_geo, data] of usedGeometries) {
            totalVertices += data.vertexCount * data.count;
            totalIndices += data.indexCount * data.count;
            // maxVertices = Math.max(maxVertices, geo.attributes.position.count * count);
        }
        // we calculate the average to make an educated guess of how many vertices will be needed with the new buffer count
        const averageVerts = Math.ceil(totalVertices / Math.max(1, this._currentInstanceCount));
        let maxVertexCount = averageVerts * newMaxInstances;
        const averageIndices = Math.ceil(totalIndices / Math.max(1, this._currentInstanceCount));
        let maxIndexCount = averageIndices * newMaxInstances * 2;

        // if new geometries are provided we *know* that they will be added
        // so we make sure to include them in the calculation
        if (_newGeometries) {
            for (const geo of _newGeometries) {
                const meshinfo = getMeshInformation(geo);
                maxVertexCount += meshinfo.vertexCount * newGeometriesFactor;
                maxIndexCount += meshinfo.indexCount * newGeometriesFactor;

            }
        }

        return { vertexCount: maxVertexCount, indexCount: maxIndexCount };
    }


    private readonly _availableBuckets = new Array<BucketInfo>();
    private readonly _usedBuckets = new Array<BucketInfo>();

    private addGeometry(handle: InstanceHandle) {
        // if (handle.reservedVertexCount <= 0 || handle.reservedIndexCount <= 0) {
        //     console.error("Cannot add geometry with 0 vertices or indices", handle.name);
        //     return;
        // }
        // search the smallest available bucket that fits our handle
        let smallestBucket: BucketInfo | null = null;
        let smallestBucketIndex = -1;
        for (let i = this._availableBuckets.length - 1; i >= 0; i--) {
            const bucket = this._availableBuckets[i];
            if (bucket.vertexCount >= handle.maxVertexCount && bucket.indexCount >= handle.maxIndexCount) {
                if (smallestBucket == null || bucket.vertexCount < smallestBucket.vertexCount) {
                    smallestBucket = bucket;
                    smallestBucketIndex = i;
                }
            }
        }
        // if we have a bucket that is big enough, use it
        if (smallestBucket != null) {
            const bucket = smallestBucket;
            if (debugInstancing)
                console.debug(`RE-USE SPACE #${bucket.index}, ${handle.maxVertexCount} vertices, ${handle.maxIndexCount} indices, ${handle.name}`);
            this.inst.setGeometryAt(bucket.index, handle.object.geometry as BufferGeometry);
            this.inst.setMatrixAt(bucket.index, handle.object.matrixWorld);
            this.inst.setVisibleAt(bucket.index, true);
            handle.__instanceIndex = bucket.index;
            this._usedBuckets[bucket.index] = bucket;
            this._availableBuckets.splice(smallestBucketIndex, 1);
            return;
        }

        // otherwise add more geometry
        const geo = handle.object.geometry as BufferGeometry;


        if (debugInstancing) console.debug("ADD GEOMETRY", geo.name, "\nvertex:", `${this._currentVertexCount} + ${handle.maxVertexCount} < ${this._maxVertexCount}?`, "\nindex:", handle.maxIndexCount, this._currentIndexCount, this._maxIndexCount);

        const i = this.inst.addGeometry(geo, handle.maxVertexCount, handle.maxIndexCount);
        handle.__instanceIndex = i;
        handle.__reservedVertexRange = handle.maxVertexCount;
        handle.__reservedIndexRange = handle.maxIndexCount;
        this._currentVertexCount += handle.maxVertexCount;
        this._currentIndexCount += handle.maxIndexCount;
        this._usedBuckets[i] = { index: i, vertexCount: handle.maxVertexCount, indexCount: handle.maxIndexCount };
        this.inst.setMatrixAt(i, handle.object.matrixWorld);
        if (debugInstancing)
            console.debug(`ADD MESH & RESERVE SPACE #${i}, ${handle.maxVertexCount} vertices, ${handle.maxIndexCount} indices, ${handle.name} ${handle.object.uuid}`);

    }

    private removeGeometry(handle: InstanceHandle, _del: boolean) {
        if (handle.__instanceIndex < 0) return;
        this._usedBuckets.splice(handle.__instanceIndex, 1);
        // deleteGeometry is currently not useable since there's no optimize method
        // https://github.com/mrdoob/three.js/issues/27985
        // if (del)
        //     this.inst.deleteGeometry(handle.__instanceIndex);
        // else 
        this.inst.setVisibleAt(handle.__instanceIndex, false);
        this._availableBuckets.push({
            index: handle.__instanceIndex,
            vertexCount: handle.reservedVertexCount,
            indexCount: handle.reservedIndexCount
        });
    }
}

declare type BucketInfo = {
    index: number;
    vertexCount: number;
    indexCount: number;
}

declare type MeshInformation = {
    vertexCount: number;
    indexCount: number;
}

function getMeshInformation(geo: BufferGeometry): MeshInformation {
    let vertexCount = geo.attributes.position.count;
    let indexCount = geo.index ? geo.index.count : 0;
    const lodInfo = NEEDLE_progressive.getMeshLODInformation(geo);
    if (lodInfo) {
        const lod0 = lodInfo.lods[0];
        let lod0Count = lod0.vertexCount;
        let lod0IndexCount = lod0.indexCount;
        // add some wiggle room: https://linear.app/needle/issue/NE-4505
        lod0Count += 10;
        lod0Count += lod0Count * .05;
        lod0IndexCount += 20;
        vertexCount = Math.max(vertexCount, lod0Count);
        indexCount = Math.max(indexCount, lod0IndexCount);
    }
    vertexCount = Math.ceil(vertexCount);
    indexCount = Math.ceil(indexCount);
    return { vertexCount, indexCount };
}

function createDebugMaterial() {
    const mat = new MeshStandardMaterial({ color: new Color(Math.random(), Math.random(), Math.random()) });
    mat.emissive = mat.color;
    mat.emissiveIntensity = .3;
    if (getParam("wireframe"))
        mat.wireframe = true;
    return mat;
}
