import { BufferAttribute, BufferGeometry, Color, DoubleSide, Material, Mesh, MeshBasicMaterial, NearestFilter, SRGBColorSpace, Texture } from "three";

import { Context } from "../engine/engine_context.js";
import { serializable, serializeable } from "../engine/engine_serialization_decorator.js";
import { getParam } from "../engine/engine_utils.js";
import { NEEDLE_progressive } from "../engine/extensions/NEEDLE_progressive.js";
import { RGBAColor } from "../engine/js-extensions/index.js";
import { Behaviour } from "./Component.js";

const debug = getParam("debugspriterenderer");
const showWireframe = getParam("wireframe");

class SpriteUtils {

    static cache: { [key: string]: BufferGeometry } = {};

    static getOrCreateGeometry(sprite: Sprite): BufferGeometry {
        if (sprite.__cached_geometry) return sprite.__cached_geometry;
        if (sprite.guid) {
            if (SpriteUtils.cache[sprite.guid]) {
                if (debug) console.log("Take cached geometry for sprite", sprite.guid);
                return SpriteUtils.cache[sprite.guid];
            }
        }
        const geo = new BufferGeometry();
        sprite.__cached_geometry = geo;
        const vertices = new Float32Array(sprite.triangles.length * 3);
        const uvs = new Float32Array(sprite.triangles.length * 2);
        for (let i = 0; i < sprite.triangles.length; i += 1) {
            const index = sprite.triangles[i];

            vertices[i * 3] = -sprite.vertices[index].x;
            vertices[i * 3 + 1] = sprite.vertices[index].y;

            vertices[i * 3 + 2] = 0;
            const uv = sprite.uv[index];
            uvs[i * 2] = uv.x;
            uvs[i * 2 + 1] = 1 - uv.y;
        }
        geo.setAttribute("position", new BufferAttribute(vertices, 3));
        geo.setAttribute("uv", new BufferAttribute(uvs, 2));
        if (sprite.guid)
            this.cache[sprite.guid] = geo;
        if (debug)
            console.log("Built sprite geometry", sprite, geo);
        return geo;
    }
}

/// <summary>
///   <para>SpriteRenderer draw mode.</para>
/// </summary>
export enum SpriteDrawMode {
    /// <summary>
    ///   <para>Displays the full sprite.</para>
    /// </summary>
    Simple = 0,
    /// <summary>
    ///   <para>The SpriteRenderer will render the sprite as a 9-slice image where the corners will remain constant and the other sections will scale.</para>
    /// </summary>
    Sliced = 1,
    /// <summary>
    ///   <para>The SpriteRenderer will render the sprite as a 9-slice image where the corners will remain constant and the other sections will tile.</para>
    /// </summary>
    Tiled = 2,
}

class Vec2 {
    x!: number;
    y!: number;
}

/**
 * A sprite is a mesh that represents a 2D image
 */
export class Sprite {

    @serializable()
    guid?: string;
    @serializable(Texture)
    texture?: Texture;
    @serializeable()
    triangles!: Array<number>;
    @serializeable()
    uv!: Array<Vec2>;
    @serializeable()
    vertices!: Array<Vec2>;

    /** @internal */
    __cached_geometry?: BufferGeometry;

    /**
     * The mesh that represents the sprite
     */
    get mesh(): Mesh {
        if (!this._mesh) {
            this._mesh = new Mesh(SpriteUtils.getOrCreateGeometry(this), this.material);
        }
        return this._mesh;
    }
    private _mesh: Mesh | undefined;

    /**
     * The material used to render the sprite
     */
    get material() {
        if (!this._material) {
            if (this.texture) {
                this.texture.colorSpace = SRGBColorSpace;
                if (this.texture.minFilter == NearestFilter && this.texture.magFilter == NearestFilter)
                    this.texture.anisotropy = 1;
                this.texture.needsUpdate = true;
            }
            this._material = new MeshBasicMaterial({
                map: this.texture,
                color: 0xffffff,
                side: DoubleSide,
                transparent: true
            });
        }
        return this._material;
    }
    private _material: MeshBasicMaterial | undefined;

    /**
     * The geometry of the sprite that can be used to create a mesh
     */
    getGeometry() {
        return SpriteUtils.getOrCreateGeometry(this);
    }
}

const $spriteTexOwner = Symbol("spriteOwner");

export class SpriteSheet {

    @serializable(Sprite)
    sprites!: Sprite[];
}

export class SpriteData {

    @serializable(SpriteSheet)
    spriteSheet?: SpriteSheet;

    @serializable()
    index: number = 0;

    update(material: Material | undefined) {
        if (!this.spriteSheet) return;
        const index = this.index;
        if (index < 0 || index >= this.spriteSheet.sprites.length)
            return;

        const sprite = this.spriteSheet.sprites[index];
        const tex = sprite?.texture;
        if (!tex) return;
        tex.colorSpace = SRGBColorSpace;
        if (tex.minFilter == NearestFilter && tex.magFilter == NearestFilter)
            tex.anisotropy = 1;
        tex.needsUpdate = true;

        if (!sprite["__hasLoadedProgressive"]) {
            sprite["__hasLoadedProgressive"] = true;
            const previousTexture = tex;
            NEEDLE_progressive.assignTextureLOD(tex, 0).then(res => {
                if (res instanceof Texture) {
                    sprite.texture = res;
                    const shouldUpdateInMaterial = material?.["map"] === previousTexture;
                    if (shouldUpdateInMaterial) {
                        material["map"] = res;
                        material.needsUpdate = true;
                    }
                }
            });
        }
    }
}

/**
 * The sprite renderer renders a sprite on a GameObject using an assigned spritesheet ({@link SpriteData})
 */
export class SpriteRenderer extends Behaviour {

    /** @internal The draw mode of the sprite renderer */
    @serializable()
    drawMode: SpriteDrawMode = SpriteDrawMode.Simple;

    /** @internal Used when drawMode is set to Tiled */
    @serializable(Vec2)
    size: Vec2 = { x: 1, y: 1 };

    @serializable(RGBAColor)
    color?: RGBAColor;

    /**
     * The material that is used to render the sprite
     */
    @serializable(Material)
    sharedMaterial?: Material;

    // additional data
    @serializable()
    transparent: boolean = true;
    @serializable()
    cutoutThreshold: number = 0;
    @serializable()
    castShadows: boolean = false;
    @serializable()
    renderOrder: number = 0;
    @serializable()
    toneMapped: boolean = true;

    @serializable(SpriteData)
    get sprite(): SpriteData | undefined {
        return this._spriteSheet;
    }
    /**
     * Set a new sprite sheetsheet or update the index of the sprite to be rendered in the currently assigned sprite sheet
     */
    set sprite(value: SpriteData | undefined | number) {
        if (value === this._spriteSheet) return;
        if (typeof value === "number") {
            const index = Math.floor(value);
            this.spriteIndex = index;
            return;
        }
        else {
            this._spriteSheet = value;
            this.updateSprite();
        }
    }

    /**
     * Set the index of the sprite to be rendered in the currently assigned sprite sheet
     */
    set spriteIndex(value: number) {
        if (!this._spriteSheet) return;
        this._spriteSheet.index = value;
        this.updateSprite();
    }
    get spriteIndex(): number {
        return this._spriteSheet?.index ?? 0;
    }
    /**
     * Get the number of sprites in the currently assigned sprite sheet
     */
    get spriteFrames(): number {
        return this._spriteSheet?.spriteSheet?.sprites.length ?? 0;
    }

    private _spriteSheet?: SpriteData;
    private _currentSprite?: Mesh;

    /** @internal */
    awake(): void {
        this._currentSprite = undefined;
        if (debug) {
            console.log("Awake", this.name, this, this.sprite);
        }
    }

    /** @internal */
    start() {
        if (!this._currentSprite)
            this.updateSprite();
        else if (this.gameObject)
            this.gameObject.add(this._currentSprite);
    }

    /**
     * Update the sprite. Modified properties will be applied to the sprite mesh. This method is called automatically when the sprite is changed.
     */
    updateSprite(force: boolean = false) {
        if (!this.__didAwake && !force) return;
        if (!this.sprite?.spriteSheet?.sprites) return;
        const sprite = this.sprite.spriteSheet.sprites[this.spriteIndex];
        if (!sprite) {
            if (debug)
                console.warn("Sprite not found", this.spriteIndex, this.sprite.spriteSheet.sprites);
            return;
        }
        if (!this._currentSprite) {
            const mat = new MeshBasicMaterial({ color: 0xffffff, side: DoubleSide });
            if (!mat) return;
            if (showWireframe)
                mat.wireframe = true;
            if (this.color) {
                if (!mat["color"]) mat["color"] = new Color();
                mat["color"].copy(this.color);
                mat["opacity"] = this.color.alpha;
            }
            mat.transparent = true;
            mat.toneMapped = this.toneMapped;

            if (sprite.texture && !mat.wireframe) {
                let tex = sprite.texture;
                // the sprite renderer modifies the texture offset and scale
                // so we need to clone the texture
                // if the same texture is used multiple times
                if (tex[$spriteTexOwner] !== undefined && tex[$spriteTexOwner] !== this && this.spriteFrames > 1) {
                    tex = sprite!.texture = tex.clone();
                }
                tex[$spriteTexOwner] = this;
                mat["map"] = tex;
            }
            this.sharedMaterial = mat;
            this._currentSprite = new Mesh(SpriteUtils.getOrCreateGeometry(sprite), mat);
            this._currentSprite.renderOrder = Math.round(this.renderOrder);
            NEEDLE_progressive.assignTextureLOD(mat, 0);
        }
        else {
            this._currentSprite.geometry = SpriteUtils.getOrCreateGeometry(sprite);
            this._currentSprite.material["map"] = sprite.texture;
        }

        if (this._currentSprite.parent !== this.gameObject) {
            if (this.drawMode === SpriteDrawMode.Tiled)
                this._currentSprite.scale.set(this.size.x, this.size.y, 1);
            if (this.gameObject)
                this.gameObject.add(this._currentSprite);
        }

        if (this._currentSprite) {
            this._currentSprite.layers.set(this.layer)
        }

        if (this.sharedMaterial) {
            this.sharedMaterial.alphaTest = this.cutoutThreshold;
            this.sharedMaterial.transparent = this.transparent;
        }
        this._currentSprite.castShadow = this.castShadows;
        this._spriteSheet?.update( this.sharedMaterial);
    }
}
