import { type Context, FrameEvent } from "./engine_context.js";
import { ContextEvent } from "./engine_context_registry.js";
import { safeInvoke } from "./engine_generic_utils.js";

export declare type Event = ContextEvent | FrameEvent;

/**
 * A function that can be called during the Needle Engine frame event at a specific point
 * @link https://engine.needle.tools/docs/scripting.html#special-lifecycle-hooks
 */
export declare type LifecycleMethod = (ctx: Context) => void;
/** 
 * Options for `onStart(()=>{})` etc event hooks
 * @link https://engine.needle.tools/docs/scripting.html#special-lifecycle-hooks
 */
export declare type LifecycleMethodOptions = {
    /**
     * If true, the callback will only be called once
     */
    once?: boolean
};


declare type RegisteredLifecycleMethod = { method: LifecycleMethod, options: LifecycleMethodOptions };


const allMethods = new Map<Event, Array<RegisteredLifecycleMethod>>();
const _started = new WeakSet<Context>();


/** register a function to be called during the Needle Engine frame event at a specific point  
 * @param cb the function to call
 * @param evt the event to call the function at
 */
export function registerFrameEventCallback(cb: LifecycleMethod, evt: Event, opts?: LifecycleMethodOptions) {
    if (!allMethods.has(evt)) {
        allMethods.set(evt, new Array());
    }
    allMethods.get(evt)!.push({
        method: cb,
        options: { once: false, ...opts }
    });
}
/**
 * unregister a function to be called during the Needle Engine frame event at a specific point  
 */
export function unregisterFrameEventCallback(cb: LifecycleMethod, evt: Event) {
    const methods = allMethods.get(evt);
    if (methods) {
        for (let i = 0; i < methods.length; i++) {
            if (methods[i].method === cb) {
                methods.splice(i, 1);
                return;
            }
        }
    }

}

export function invokeLifecycleFunctions(ctx: Context, evt: Event) {

    // When a context is created, we need to reset the started state
    // Because we want to invoke `onStart` again (even if it's the same context)
    if (evt === ContextEvent.ContextCreated) {
        _started.delete(ctx);
    }

    const methods = allMethods.get(evt);
    if (methods) {
        if (methods.length > 0) {
            const array = methods;
            if (evt === FrameEvent.Start) {
                if (_started.has(ctx)) {
                    return;
                }
                else {
                    _started.add(ctx);
                }
            }
            invoke(ctx, array);
        }
    }
}

const bufferArray = new Array<RegisteredLifecycleMethod>();
function invoke(ctx: Context, methods: Array<RegisteredLifecycleMethod>) {
    bufferArray.length = 0;
    for (let i = 0; i < methods.length; i++) {
        bufferArray.push(methods[i]);
    }
    for (let i = 0; i < bufferArray.length; i++) {
        const entry = bufferArray[i];
        safeInvoke(entry.method, ctx);

        // Remove the method if it's a one time call
        if (entry.options?.once) {
            for (let j = 0; j < methods.length; j++) {
                if (methods[j] === entry) {
                    methods.splice(j, 1);
                    break;
                }
            }
        }
    }
}