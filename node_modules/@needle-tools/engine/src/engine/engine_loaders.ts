
import { createLoaders, setDracoDecoderLocation, setKTX2TranscoderLocation } from '@needle-tools/gltf-progressive';
import { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js'
import { KTX2Loader } from 'three/examples/jsm/loaders/KTX2Loader.js';

import { isDevEnvironment } from './debug/index.js';
import { Context } from "./engine_setup.js"
import { getParam } from "./engine_utils.js";

const debug = getParam("debugdecoders");

// NOTE: keep in sync with gltf-progressive
let DEFAULT_DRACO_DECODER_LOCATION = 'https://www.gstatic.com/draco/versioned/decoders/1.5.7/';
let DEFAULT_KTX2_TRANSCODER_LOCATION = 'https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/';
fetch(DEFAULT_DRACO_DECODER_LOCATION + "draco_decoder.js", { method: "head" })
    .catch(_ => {
        if (isDevEnvironment()) console.warn("Failed to load draco decoder from \"" + DEFAULT_DRACO_DECODER_LOCATION + "\".\nFalling back to local version at \"./include/draco\"");
        DEFAULT_DRACO_DECODER_LOCATION = "./include/draco/";
        DEFAULT_KTX2_TRANSCODER_LOCATION = "./include/ktx2/";
    });


let meshoptDecoder: typeof MeshoptDecoder;

let loaders: null | { dracoLoader: DRACOLoader, ktx2Loader: KTX2Loader, meshoptDecoder: typeof MeshoptDecoder } = null;

function ensureLoaders() {
    if (!loaders) {
        const res = createLoaders(null);
        loaders = { dracoLoader: res.dracoLoader, ktx2Loader: res.ktx2Loader, meshoptDecoder: res.meshoptDecoder };
    }
    return loaders;
}

export function setDracoDecoderPath(path: string | undefined) {
    if (path !== undefined && typeof path === "string") {
        const loaders = ensureLoaders();
        if (debug) console.log("Setting draco decoder path to", path);
        loaders.dracoLoader.setDecoderPath(path);
        setDracoDecoderLocation(path);
    }
}

export function setDracoDecoderType(type: string | undefined) {
    if (type !== undefined && typeof type === "string") {
        const loaders = ensureLoaders();
        if (debug) console.log("Setting draco decoder type to", type);
        loaders.dracoLoader.setDecoderConfig({ type: type });
    }
}

export function setKtx2TranscoderPath(path: string) {
    if (path !== undefined && typeof path === "string") {
        const loaders = ensureLoaders();
        if (debug) console.log("Setting ktx2 transcoder path to", path);
        loaders.ktx2Loader.setTranscoderPath(path);
        setKTX2TranscoderLocation(path);
    }
}

export function setMeshoptDecoder(_meshoptDecoder: any) {
    if (_meshoptDecoder !== undefined)
        meshoptDecoder = _meshoptDecoder;
}

/**
 * Add Draco, Meshopt and KTX2 loaders to a GLTFLoader instance.
 * @param loader The GLTFLoader instance to add the loaders to.
 * @param context The context object containing the renderer.
 * @returns The GLTFLoader instance with the loaders added.
 */
export function addDracoAndKTX2Loaders(loader: GLTFLoader, context: Pick<Context, "renderer">) {
    
    const loaders = ensureLoaders();

    if (!meshoptDecoder) {
        meshoptDecoder = loaders.meshoptDecoder;
        if (debug) console.log("Using the default meshopt decoder");
    }


    if (context.renderer) {
        loaders.ktx2Loader.detectSupport(context.renderer);
    }
    else
        console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures will probably fail");

    if (!loader.dracoLoader)
        loader.setDRACOLoader(loaders.dracoLoader);
    if (!(loader as any).ktx2Loader)
        loader.setKTX2Loader(loaders.ktx2Loader);
    if (!(loader as any).meshoptDecoder)
        loader.setMeshoptDecoder(meshoptDecoder);
    return loader;
}
