import { Camera, Color, PerspectiveCamera } from "three";

import { Renderer } from "../engine-components/Renderer.js";
import { getComponentsInChildren } from "./engine_components.js";
import { ContextRegistry } from "./engine_context_registry.js";
import { Context } from "./engine_setup.js";

declare type ScreenshotImageMimeType = "image/webp" | "image/png";

/** 
 * Take a screenshot from the current scene.  
 * **NOTE**: Use {@link screenshot2} for more options.  
 * 
 * @param context The context to take the screenshot from
 * @param width The width of the screenshot
 * @param height The height of the screenshot
 * @param mimeType The mime type of the image
 * @param camera The camera to use for the screenshot
 * @returns The data url of the screenshot. Returns null if the screenshot could not be taken.
 * @example
 * ```ts
 * const dataUrl = screenshot();
 * saveImage(dataUrl, "screenshot.png");
 * ```
 */
export function screenshot(context?: Context, width?: number, height?: number, mimeType: ScreenshotImageMimeType = "image/webp", camera?: Camera | null): string | null {
    return screenshot2({ context, width, height, mimeType, camera });
}


/**
 * Options for the {@link screenshot2} function.
 */
export declare type ScreenshotOptions = {
    /**
     * The context to take the screenshot from. If not provided, the current context will be used.
     */
    context?: Pick<Context, "scene" | "renderer" | "mainCamera" | "renderNow" | "updateAspect" | "updateSize">,
    /**
     * The width of the screenshot - if not provided, the width of the current renderer will be used.
     */
    width?: number,
    /**
     * The height of the screenshot - if not provided, the height of the current renderer will be used.
     */
    height?: number,
    /**
     * The mime type of the image
     */
    mimeType?: ScreenshotImageMimeType,
    /**
     * The camera to use for the screenshot. If not provided, the main camera of the context will be used.
     */
    camera?: Camera | null,
    /**
     * If true, the background will be transparent.
     */
    transparent?: boolean,

    /**
     * If set the screenshot will be downloaded using the provided filename.   
     * NOTE: if you need more control you can manually download the returned image using {@link saveImage}
     * @default undefined
     */
    download_filename?: string,

    /**
     * If true onBeforeRender and onAfterRender will be invoked on all renderers in the scene.
     * @default true
     */
    render_events?: boolean,
};

/**
 * Take a screenshot from the current scene.  
 * @param {ScreenshotOptions} opts
 * @returns The data url of the screenshot. Returns null if the screenshot could not be taken.
 * ```ts	
 * const res = screenshot2({
 *    width: 1024,
 *   height: 1024,
 *  mimeType: "image/webp",
 * transparent: true,
 * })
 * // use saveImage to download the image
 * saveImage(res, "screenshot.webp");
 * ```
 */
export function screenshot2(opts: ScreenshotOptions = {
    mimeType: "image/png",
    transparent: false,
}): string | null {

    if (!opts) opts = {}

    let { context, width, height, camera } = opts;
    const { mimeType } = opts;

    if (!context) {
        context = ContextRegistry.Current as Context;
        if (!context) {
            console.error("Can not save screenshot: No needle-engine context found or provided.");
            return null;
        }
    }

    if (!camera) {
        camera = context.mainCamera;
        if (!camera) {
            console.error("No camera found");
            return null;
        }
    }
    const prevWidth = context.renderer.domElement.width;
    const prevHeight = context.renderer.domElement.height;

    if (!width) width = prevWidth;
    if (!height) height = prevHeight;

    // apply page zoom
    const zoomLevel = window.devicePixelRatio || 1;
    width /= zoomLevel;
    height /= zoomLevel;

    // reset style during screenshot
    context.renderer.domElement.style.width = width + "px";
    context.renderer.domElement.style.height = height + "px";

    const previousClearColor = context.renderer.getClearColor(new Color());
    const previousClearAlpha = context.renderer.getClearAlpha();

    try {
        if (opts?.transparent) {
            context.renderer.setClearColor(0x000000, 0);
        }

        const canvas = context.renderer.domElement;

        // set the desired output size
        context.renderer.setSize(width, height, false);

        // update the camera aspect and matrix
        if (camera instanceof PerspectiveCamera)
            context.updateAspect(camera, width, height);


        // Calling onBeforeRender to update objects with reflection probes. https://linear.app/needle/issue/NE-5112
        const callRenderEvents = opts.render_events !== false;
        const renderers = new Array<Renderer>();
        if (callRenderEvents) {
            getComponentsInChildren(context.scene, Renderer, renderers);
            renderers.forEach(r => r?.onBeforeRender());
        }

        // render now
        context.renderNow();

        if (callRenderEvents)
            renderers.forEach(r => r.onAfterRender());

        const dataUrl = canvas.toDataURL(mimeType);

        if (opts.download_filename) {
            saveImage(dataUrl, opts.download_filename);
        }

        return dataUrl;
    }
    finally {
        context.renderer.setSize(prevWidth, prevHeight, false);
        context.updateSize();
        context.renderer.setClearColor(previousClearColor, previousClearAlpha);
    }

    return null;
}

let saveImageElement: HTMLAnchorElement | null = null;

/** Download a image (must be a data url).
 * @param dataUrl The data url of the image
 * @param filename The filename of the image
 * @example
 * ```ts
 * const dataUrl = screenshot();
 * saveImage(dataUrl, "screenshot.png");
 * ```
 */
export function saveImage(dataUrl: string | null, filename: string) {
    if (!dataUrl) {
        return;
    }
    if (!dataUrl.startsWith("data:image")) {
        console.error("Can not save image: Data url is not an image", dataUrl);
        return;
    }
    if (!saveImageElement) {
        saveImageElement = document.createElement("a");
    }
    saveImageElement.href = dataUrl;
    saveImageElement.download = filename;
    saveImageElement.click();
}