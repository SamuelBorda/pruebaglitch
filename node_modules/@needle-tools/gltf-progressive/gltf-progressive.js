var $e = Object.defineProperty;
var Ue = (a, t, e) => t in a ? $e(a, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : a[t] = e;
var d = (a, t, e) => (Ue(a, typeof t != "symbol" ? t + "" : t, e), e), _e = (a, t, e) => {
  if (!t.has(a))
    throw TypeError("Cannot " + e);
};
var m = (a, t, e) => (_e(a, t, "read from private field"), e ? e.call(a) : t.get(a)), K = (a, t, e) => {
  if (t.has(a))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(a) : t.set(a, e);
}, U = (a, t, e, s) => (_e(a, t, "write to private field"), s ? s.call(a, e) : t.set(a, e), e);
import { BufferGeometry as de, Mesh as H, Material as ze, Texture as te, TextureLoader as Ve, Matrix4 as Se, Clock as Ne, MeshStandardMaterial as We, Sphere as qe, Box3 as be, Vector3 as z } from "three";
import { GLTFLoader as Xe } from "three/examples/jsm/loaders/GLTFLoader.js";
import { MeshoptDecoder as Ke } from "three/examples/jsm/libs/meshopt_decoder.module.js";
import { DRACOLoader as Ye } from "three/examples/jsm/loaders/DRACOLoader.js";
import { KTX2Loader as He } from "three/examples/jsm/loaders/KTX2Loader.js";
const Ce = "";
globalThis.GLTF_PROGRESSIVE_VERSION = Ce;
console.debug(`[gltf-progressive] version ${Ce}`);
let he = "https://www.gstatic.com/draco/versioned/decoders/1.4.1/", Oe = "https://www.gstatic.com/basis-universal/versioned/2021-04-15-ba1c3e4/";
fetch(he + "draco_decoder.js", { method: "head" }).catch((a) => {
  he = "./include/draco/", Oe = "./include/ktx2/";
});
function dt(a) {
  he = a;
}
function ht(a) {
  Oe = a;
}
let Q, fe, Z;
function Be(a) {
  return Q || (Q = new Ye(), Q.setDecoderPath(he), Q.setDecoderConfig({ type: "js" })), Z || (Z = new He(), Z.setTranscoderPath(Oe)), fe || (fe = Ke), a ? Z.detectSupport(a) : a !== null && console.warn("No renderer provided to detect ktx2 support - loading KTX2 textures might fail"), { dracoLoader: Q, ktx2Loader: Z, meshoptDecoder: fe };
}
function Ie(a) {
  a.dracoLoader || a.setDRACOLoader(Q), a.ktx2Loader || a.setKTX2Loader(Z), a.meshoptDecoder || a.setMeshoptDecoder(fe);
}
oe("debugprogressive");
function oe(a) {
  const e = new URL(window.location.href).searchParams.get(a);
  return e == null || e === "0" || e === "false" ? !1 : e === "" ? !0 : e;
}
function Je(a, t) {
  if (t === void 0 || t.startsWith("./") || t.startsWith("http") || a === void 0)
    return t;
  const e = a.lastIndexOf("/");
  if (e >= 0) {
    const s = a.substring(0, e + 1);
    for (; s.endsWith("/") && t.startsWith("/"); )
      t = t.substring(1);
    return s + t;
  }
  return t;
}
let se;
function Qe() {
  return se !== void 0 || (se = /iPhone|iPad|iPod|Android|IEMobile/i.test(navigator.userAgent), oe("debugprogressive") && console.log("[glTF Progressive]: isMobileDevice", se)), se;
}
const we = Symbol("needle:raycast-mesh");
function ye(a) {
  return (a == null ? void 0 : a[we]) instanceof de ? a[we] : null;
}
function Ze(a, t) {
  if ((a.type === "Mesh" || a.type === "SkinnedMesh") && !ye(a)) {
    const s = je(t);
    s.userData = { isRaycastMesh: !0 }, a[we] = s;
  }
}
function gt(a = !0) {
  if (a) {
    if (re)
      return;
    const t = re = H.prototype.raycast;
    H.prototype.raycast = function(e, s) {
      const n = this, r = ye(n);
      let i;
      r && n.isMesh && (i = n.geometry, n.geometry = r), t.call(this, e, s), i && (n.geometry = i);
    };
  } else {
    if (!re)
      return;
    H.prototype.raycast = re, re = null;
  }
}
let re = null;
function je(a) {
  const t = new de();
  for (const e in a.attributes)
    t.setAttribute(e, a.getAttribute(e));
  return t.setIndex(a.getIndex()), t;
}
const Y = new Array(), V = "NEEDLE_progressive", x = oe("debugprogressive"), Le = Symbol("needle-progressive-texture"), ne = /* @__PURE__ */ new Map(), ve = /* @__PURE__ */ new Set();
if (x) {
  let a = function() {
    t += 1, console.log("Toggle LOD level", t, ne), ne.forEach((n, r) => {
      for (const i of n.keys) {
        const o = r[i];
        if (o != null) {
          if (o.isBufferGeometry === !0) {
            const l = _.getMeshLODInformation(o), u = l ? Math.min(t, l.lods.length) : 0;
            r["DEBUG:LOD"] = t, _.assignMeshLOD(r, u), l && (e = Math.max(e, l.lods.length - 1));
          } else if (r.isMaterial === !0) {
            r["DEBUG:LOD"] = t, _.assignTextureLOD(r, t);
            break;
          }
        }
      }
    }), t >= e && (t = -1);
  }, t = -1, e = 2, s = !1;
  window.addEventListener("keyup", (n) => {
    n.key === "p" && a(), n.key === "w" && (s = !s, ve && ve.forEach((r) => {
      r.name != "BackgroundCubeMaterial" && r.glyphMap == null && "wireframe" in r && (r.wireframe = s);
    }));
  });
}
function Te(a, t, e) {
  var n;
  if (!x)
    return;
  ne.has(a) || ne.set(a, { keys: [], sourceId: e });
  const s = ne.get(a);
  ((n = s == null ? void 0 : s.keys) == null ? void 0 : n.includes(t)) == !1 && s.keys.push(t);
}
const v = class {
  constructor(t, e) {
    d(this, "parser");
    d(this, "url");
    d(this, "_isLoadingMesh");
    d(this, "loadMesh", (t) => {
      var s, n;
      if (this._isLoadingMesh)
        return null;
      const e = (n = (s = this.parser.json.meshes[t]) == null ? void 0 : s.extensions) == null ? void 0 : n[V];
      return e ? (this._isLoadingMesh = !0, this.parser.getDependency("mesh", t).then((r) => {
        var i;
        return this._isLoadingMesh = !1, r && v.registerMesh(this.url, e.guid, r, (i = e.lods) == null ? void 0 : i.length, void 0, e), r;
      })) : null;
    });
    x && console.log("Progressive extension registered for", e), this.parser = t, this.url = e;
  }
  /** The name of the extension */
  get name() {
    return V;
  }
  static getMeshLODInformation(t) {
    const e = this.getAssignedLODInformation(t);
    return e != null && e.key ? this.lodInfos.get(e.key) : null;
  }
  static getMaterialMinMaxLODsCount(t, e) {
    const s = this, n = "LODS:minmax", r = t[n];
    if (r != null)
      return r;
    if (e || (e = {
      min_count: 1 / 0,
      max_count: 0,
      lods: []
    }), Array.isArray(t)) {
      for (const o of t)
        this.getMaterialMinMaxLODsCount(o, e);
      return t[n] = e, e;
    }
    if (x === "verbose" && console.log("getMaterialMinMaxLODsCount", t), t.type === "ShaderMaterial" || t.type === "RawShaderMaterial") {
      const o = t;
      for (const l of Object.keys(o.uniforms)) {
        const u = o.uniforms[l].value;
        (u == null ? void 0 : u.isTexture) === !0 && i(u, e);
      }
    } else if (t.isMaterial)
      for (const o of Object.keys(t)) {
        const l = t[o];
        (l == null ? void 0 : l.isTexture) === !0 && i(l, e);
      }
    return t[n] = e, e;
    function i(o, l) {
      const u = s.getAssignedLODInformation(o);
      if (u) {
        const c = s.lodInfos.get(u.key);
        if (c && c.lods) {
          l.min_count = Math.min(l.min_count, c.lods.length), l.max_count = Math.max(l.max_count, c.lods.length);
          for (let g = 0; g < c.lods.length; g++) {
            const p = c.lods[g];
            p.width && (l.lods[g] = l.lods[g] || { min_height: 1 / 0, max_height: 0 }, l.lods[g].min_height = Math.min(l.lods[g].min_height, p.height), l.lods[g].max_height = Math.max(l.lods[g].max_height, p.height));
          }
        }
      }
    }
  }
  /** Check if a LOD level is available for a mesh or a texture
   * @param obj the mesh or texture to check
   * @param level the level of detail to check for (0 is the highest resolution). If undefined, the function checks if any LOD level is available
   * @returns true if the LOD level is available (or if any LOD level is available if level is undefined)
   */
  static hasLODLevelAvailable(t, e) {
    var r;
    if (Array.isArray(t)) {
      for (const i of t)
        if (this.hasLODLevelAvailable(i, e))
          return !0;
      return !1;
    }
    if (t.isMaterial === !0) {
      for (const i of Object.keys(t)) {
        const o = t[i];
        if (o && o.isTexture && this.hasLODLevelAvailable(o, e))
          return !0;
      }
      return !1;
    } else if (t.isGroup === !0) {
      for (const i of t.children)
        if (i.isMesh === !0 && this.hasLODLevelAvailable(i, e))
          return !0;
    }
    let s, n;
    if (t.isMesh ? s = t.geometry : (t.isBufferGeometry || t.isTexture) && (s = t), s && (r = s == null ? void 0 : s.userData) != null && r.LODS) {
      const i = s.userData.LODS;
      if (n = this.lodInfos.get(i.key), e === void 0)
        return n != null;
      if (n)
        return Array.isArray(n.lods) ? e < n.lods.length : e === 0;
    }
    return !1;
  }
  /** Load a different resolution of a mesh (if available)
   * @param context the context
   * @param source the sourceid of the file from which the mesh is loaded (this is usually the component's sourceId)
   * @param mesh the mesh to load the LOD for
   * @param level the level of detail to load (0 is the highest resolution)
   * @returns a promise that resolves to the mesh with the requested LOD level
   * @example
   * ```javascript
   * const mesh = this.gameObject as Mesh;
   * NEEDLE_progressive.assignMeshLOD(context, sourceId, mesh, 1).then(mesh => {
   *    console.log("Mesh with LOD level 1 loaded", mesh);
   * });
   * ```
   */
  static assignMeshLOD(t, e) {
    var s;
    if (!t)
      return Promise.resolve(null);
    if (t instanceof H || t.isMesh === !0) {
      const n = t.geometry, r = this.getAssignedLODInformation(n);
      if (!r)
        return Promise.resolve(null);
      for (const i of Y)
        (s = i.onBeforeGetLODMesh) == null || s.call(i, t, e);
      return t["LOD:requested level"] = e, v.getOrLoadLOD(n, e).then((i) => {
        if (t["LOD:requested level"] === e) {
          if (delete t["LOD:requested level"], Array.isArray(i)) {
            const o = r.index || 0;
            i = i[o];
          }
          i && n != i && ((i == null ? void 0 : i.isBufferGeometry) ? (t.geometry = i, x && Te(t, "geometry", r.url)) : x && console.error("Invalid LOD geometry", i));
        }
        return i;
      }).catch((i) => (console.error("Error loading mesh LOD", t, i), null));
    } else
      x && console.error("Invalid call to assignMeshLOD: Request mesh LOD but the object is not a mesh", t);
    return Promise.resolve(null);
  }
  /** Load a different resolution of a texture (if available)  
   * @param context the context
   * @param source the sourceid of the file from which the texture is loaded (this is usually the component's sourceId)
   * @param materialOrTexture the material or texture to load the LOD for (if passing in a material all textures in the material will be loaded)
   * @param level the level of detail to load (0 is the highest resolution) - currently only 0 is supported
   * @returns a promise that resolves to the material or texture with the requested LOD level
   */
  static assignTextureLOD(t, e = 0) {
    if (!t)
      return Promise.resolve(null);
    if (t instanceof ze || t.isMaterial === !0) {
      const s = t, n = [], r = new Array();
      if (x && ve.add(s), s.uniforms && s.isRawShaderMaterial || s.isShaderMaterial === !0) {
        const i = s;
        for (const o of Object.keys(i.uniforms)) {
          const l = i.uniforms[o].value;
          if ((l == null ? void 0 : l.isTexture) === !0) {
            const u = this.assignTextureLODForSlot(l, e, s, o);
            n.push(u), r.push(o);
          }
        }
      } else
        for (const i of Object.keys(s)) {
          const o = s[i];
          if ((o == null ? void 0 : o.isTexture) === !0) {
            const l = this.assignTextureLODForSlot(o, e, s, i);
            n.push(l), r.push(i);
          }
        }
      return Promise.all(n).then((i) => {
        const o = new Array();
        for (let l = 0; l < i.length; l++) {
          const u = i[l], c = r[l];
          u && u.isTexture === !0 ? o.push({ material: s, slot: c, texture: u, level: e }) : o.push({ material: s, slot: c, texture: null, level: e });
        }
        return o;
      });
    }
    if (t instanceof te || t.isTexture === !0) {
      const s = t;
      return this.assignTextureLODForSlot(s, e, null, null);
    }
    return Promise.resolve(null);
  }
  static assignTextureLODForSlot(t, e, s, n) {
    return (t == null ? void 0 : t.isTexture) !== !0 ? Promise.resolve(null) : n === "glyphMap" ? Promise.resolve(t) : v.getOrLoadLOD(t, e).then((r) => {
      if (Array.isArray(r))
        return null;
      if ((r == null ? void 0 : r.isTexture) === !0) {
        if (r != t) {
          if (s && n) {
            const i = s[n];
            if (i) {
              const o = this.getAssignedLODInformation(i);
              if (o && (o == null ? void 0 : o.level) < e)
                return x === "verbose" && console.warn("Assigned texture level is already higher: ", o.level, e, s, i, r), null;
            }
            s[n] = r;
          }
          if (x && n && s) {
            const i = this.getAssignedLODInformation(t);
            i && Te(s, n, i.url);
          }
        }
        return r;
      } else
        x == "verbose" && console.warn("No LOD found for", t, e);
      return null;
    }).catch((r) => (console.error("Error loading LOD", t, r), null));
  }
  afterRoot(t) {
    var e, s;
    return x && console.log("AFTER", this.url, t), (e = this.parser.json.textures) == null || e.forEach((n, r) => {
      var i;
      if (n != null && n.extensions) {
        const o = n == null ? void 0 : n.extensions[V];
        if (o) {
          if (!o.lods) {
            x && console.warn("Texture has no LODs", o);
            return;
          }
          let l = !1;
          for (const u of this.parser.associations.keys())
            if (u.isTexture === !0) {
              const c = this.parser.associations.get(u);
              (c == null ? void 0 : c.textures) === r && (l = !0, v.registerTexture(this.url, u, (i = o.lods) == null ? void 0 : i.length, r, o));
            }
          l || this.parser.getDependency("texture", r).then((u) => {
            var c;
            u && v.registerTexture(this.url, u, (c = o.lods) == null ? void 0 : c.length, r, o);
          });
        }
      }
    }), (s = this.parser.json.meshes) == null || s.forEach((n, r) => {
      if (n != null && n.extensions) {
        const i = n == null ? void 0 : n.extensions[V];
        if (i && i.lods) {
          for (const o of this.parser.associations.keys())
            if (o.isMesh) {
              const l = this.parser.associations.get(o);
              (l == null ? void 0 : l.meshes) === r && v.registerMesh(this.url, i.guid, o, i.lods.length, l.primitives, i);
            }
        }
      }
    }), null;
  }
  static async getOrLoadLOD(t, e) {
    var o, l, u, c;
    const s = x == "verbose", n = t.userData.LODS;
    if (!n)
      return null;
    const r = n == null ? void 0 : n.key;
    let i;
    if (t.isTexture === !0) {
      const g = t;
      g.source && g.source[Le] && (i = g.source[Le]);
    }
    if (i || (i = v.lodInfos.get(r)), i) {
      if (e > 0) {
        let M = !1;
        const w = Array.isArray(i.lods);
        if (w && e >= i.lods.length ? M = !0 : w || (M = !0), M)
          return this.lowresCache.get(r);
      }
      const g = Array.isArray(i.lods) ? (o = i.lods[e]) == null ? void 0 : o.path : i.lods;
      if (!g)
        return x && !i["missing:uri"] && (i["missing:uri"] = !0, console.warn("Missing uri for progressive asset for LOD " + e, i)), null;
      const p = Je(n.url, g);
      if (p.endsWith(".glb") || p.endsWith(".gltf")) {
        if (!i.guid)
          return console.warn("missing pointer for glb/gltf texture", i), null;
        const M = p + "_" + i.guid, w = this.previouslyLoaded.get(M);
        if (w !== void 0) {
          s && console.log(`LOD ${e} was already loading/loaded: ${M}`);
          let h = await w.catch(($) => (console.error(`Error loading LOD ${e} from ${p}
`, $), null)), B = !1;
          if (h == null || (h instanceof te && t instanceof te ? (l = h.image) != null && l.data || (u = h.source) != null && u.data ? h = this.copySettings(t, h) : (B = !0, this.previouslyLoaded.delete(M)) : h instanceof de && t instanceof de && ((c = h.attributes.position) != null && c.array || (B = !0, this.previouslyLoaded.delete(M)))), !B)
            return h;
        }
        const L = i, F = new Promise(async (h, B) => {
          const $ = new Xe();
          Ie($), x && (await new Promise((A) => setTimeout(A, 1e3)), s && console.warn("Start loading (delayed) " + p, L.guid));
          let I = p;
          if (L && Array.isArray(L.lods)) {
            const A = L.lods[e];
            A.hash && (I += "?v=" + A.hash);
          }
          const S = await $.loadAsync(I).catch((A) => (console.error(`Error loading LOD ${e} from ${p}
`, A), null));
          if (!S)
            return null;
          const q = S.parser;
          s && console.log("Loading finished " + p, L.guid);
          let T = 0;
          if (S.parser.json.textures) {
            let A = !1;
            for (const f of S.parser.json.textures) {
              if (f != null && f.extensions) {
                const y = f == null ? void 0 : f.extensions[V];
                if (y != null && y.guid && y.guid === L.guid) {
                  A = !0;
                  break;
                }
              }
              T++;
            }
            if (A) {
              let f = await q.getDependency("texture", T);
              return f && v.assignLODInformation(n.url, f, r, e, void 0, void 0), s && console.log('change "' + t.name + '" → "' + f.name + '"', p, T, f, M), t instanceof te && (f = this.copySettings(t, f)), f && (f.guid = L.guid), h(f);
            } else
              x && console.warn("Could not find texture with guid", L.guid, S.parser.json);
          }
          if (T = 0, S.parser.json.meshes) {
            let A = !1;
            for (const f of S.parser.json.meshes) {
              if (f != null && f.extensions) {
                const y = f == null ? void 0 : f.extensions[V];
                if (y != null && y.guid && y.guid === L.guid) {
                  A = !0;
                  break;
                }
              }
              T++;
            }
            if (A) {
              const f = await q.getDependency("mesh", T), y = L;
              if (s && console.log(`Loaded Mesh "${f.name}"`, p, T, f, M), f.isMesh === !0) {
                const O = f.geometry;
                return v.assignLODInformation(n.url, O, r, e, void 0, y.density), h(O);
              } else {
                const O = new Array();
                for (let b = 0; b < f.children.length; b++) {
                  const E = f.children[b];
                  if (E.isMesh === !0) {
                    const X = E.geometry;
                    v.assignLODInformation(n.url, X, r, e, b, y.density), O.push(X);
                  }
                }
                return h(O);
              }
            } else
              x && console.warn("Could not find mesh with guid", L.guid, S.parser.json);
          }
          return h(null);
        });
        return this.previouslyLoaded.set(M, F), await F;
      } else if (t instanceof te) {
        s && console.log("Load texture from uri: " + p);
        const w = await new Ve().loadAsync(p);
        return w ? (w.guid = i.guid, w.flipY = !1, w.needsUpdate = !0, w.colorSpace = t.colorSpace, s && console.log(i, w)) : x && console.warn("failed loading", p), w;
      }
    } else
      x && console.warn(`Can not load LOD ${e}: no LOD info found for "${r}" ${t.name}`, t.type);
    return null;
  }
  static assignLODInformation(t, e, s, n, r, i) {
    if (!e)
      return;
    e.userData || (e.userData = {});
    const o = new et(t, s, n, r, i);
    e.userData.LODS = o;
  }
  static getAssignedLODInformation(t) {
    var e;
    return ((e = t == null ? void 0 : t.userData) == null ? void 0 : e.LODS) || null;
  }
  // private static readonly _copiedTextures: WeakMap<Texture, Texture> = new Map();
  static copySettings(t, e) {
    return e = e.clone(), x && console.warn(`Copying texture settings
`, t.uuid, `
`, e.uuid), e.offset = t.offset, e.repeat = t.repeat, e.colorSpace = t.colorSpace, e.magFilter = t.magFilter, e.minFilter = t.minFilter, e.wrapS = t.wrapS, e.wrapT = t.wrapT, e.flipY = t.flipY, e.anisotropy = t.anisotropy, e.mipmaps || (e.generateMipmaps = t.generateMipmaps), e;
  }
};
let _ = v;
/**
 * Register a texture with LOD information
 */
d(_, "registerTexture", (t, e, s, n, r) => {
  if (x && console.log("> Progressive: register texture", n, e.name, e.uuid, e, r), !e) {
    x && console.error("gltf-progressive: Register texture without texture");
    return;
  }
  e.source && (e.source[Le] = r);
  const i = r.guid;
  v.assignLODInformation(t, e, i, s, n, void 0), v.lodInfos.set(i, r), v.lowresCache.set(i, e);
}), /**
 * Register a mesh with LOD information
 */
d(_, "registerMesh", (t, e, s, n, r, i) => {
  var u;
  x && console.log("> Progressive: register mesh", r, s.name, i, s.uuid, s);
  const o = s.geometry;
  if (!o) {
    x && console.warn("gltf-progressive: Register mesh without geometry");
    return;
  }
  o.userData || (o.userData = {}), v.assignLODInformation(t, o, e, n, r, i.density), v.lodInfos.set(e, i);
  let l = v.lowresCache.get(e);
  l ? l.push(s.geometry) : l = [s.geometry], v.lowresCache.set(e, l), n > 0 && !ye(s) && Ze(s, o);
  for (const c of Y)
    (u = c.onRegisteredNewMesh) == null || u.call(c, s, i);
}), /** A map of key = asset uuid and value = LOD information */
d(_, "lodInfos", /* @__PURE__ */ new Map()), /** cache of already loaded mesh lods */
d(_, "previouslyLoaded", /* @__PURE__ */ new Map()), /** this contains the geometry/textures that were originally loaded */
d(_, "lowresCache", /* @__PURE__ */ new Map());
class et {
  constructor(t, e, s, n, r) {
    d(this, "url");
    /** the key to lookup the LOD information */
    d(this, "key");
    d(this, "level");
    /** For multi objects (e.g. a group of meshes) this is the index of the object */
    d(this, "index");
    /** the mesh density */
    d(this, "density");
    this.url = t, this.key = e, this.level = s, n != null && (this.index = n), r != null && (this.density = r);
  }
}
const k = oe("debugprogressive"), tt = oe("noprogressive"), Me = Symbol("Needle:LODSManager"), De = Symbol("Needle:LODState"), J = Symbol("Needle:CurrentLOD"), R = { mesh_lod: -1, texture_lod: -1 };
var C, N, ge, j, ee, pe, W;
const P = class {
  // readonly plugins: NEEDLE_progressive_plugin[] = [];
  constructor(t, e) {
    d(this, "context");
    d(this, "renderer");
    d(this, "projectionScreenMatrix", new Se());
    /**
     * The target triangle density is the desired max amount of triangles on screen when the mesh is filling the screen.  
     * @default 200_000
     */
    d(this, "targetTriangleDensity", 2e5);
    /**
     * The update interval in frames. If set to 0, the LODs will be updated every frame. If set to 2, the LODs will be updated every second frame, etc.
     * @default "auto"
     */
    d(this, "updateInterval", "auto");
    K(this, C, 1);
    /**
     * If set to true, the LODsManager will not update the LODs.
     * @default false
     */
    d(this, "pause", !1);
    /**
     * When set to true the LODsManager will not update the LODs. This can be used to manually update the LODs using the `update` method.  
     * Otherwise the LODs will be updated automatically when the renderer renders the scene.
     * @default false
     */
    d(this, "manual", !1);
    d(this, "_lodchangedlisteners", []);
    K(this, N, void 0);
    K(this, ge, new Ne());
    K(this, j, 0);
    K(this, ee, 0);
    K(this, pe, 0);
    K(this, W, 0);
    d(this, "_fpsBuffer", [60, 60, 60, 60, 60]);
    // private testIfLODLevelsAreAvailable() {
    d(this, "_sphere", new qe());
    d(this, "_tempBox", new be());
    d(this, "_tempBox2", new be());
    d(this, "tempMatrix", new Se());
    d(this, "_tempWorldPosition", new z());
    d(this, "_tempBoxSize", new z());
    d(this, "_tempBox2Size", new z());
    this.renderer = t, this.context = { ...e };
  }
  /** @internal */
  static getObjectLODState(t) {
    return t[De];
  }
  static addPlugin(t) {
    Y.push(t);
  }
  static removePlugin(t) {
    const e = Y.indexOf(t);
    e >= 0 && Y.splice(e, 1);
  }
  /**
   * Gets the LODsManager for the given renderer. If the LODsManager does not exist yet, it will be created.  
   * @param renderer The renderer to get the LODsManager for.
   * @returns The LODsManager instance.
   */
  static get(t, e) {
    if (t[Me])
      return console.debug("[gltf-progressive] LODsManager already exists for this renderer"), t[Me];
    const s = new P(t, {
      engine: "unknown",
      ...e
    });
    return t[Me] = s, s;
  }
  /** @deprecated use static `LODsManager.addPlugin()` method. This getter will be removed in later versions */
  get plugins() {
    return Y;
  }
  addEventListener(t, e) {
    t === "changed" && this._lodchangedlisteners.push(e);
  }
  removeEventListener(t, e) {
    if (t === "changed") {
      const s = this._lodchangedlisteners.indexOf(e);
      s >= 0 && this._lodchangedlisteners.splice(s, 1);
    }
  }
  /**
   * Enable the LODsManager. This will replace the render method of the renderer with a method that updates the LODs.
   */
  enable() {
    if (m(this, N))
      return;
    console.debug("[gltf-progressive] Enabling LODsManager for renderer");
    let t = 0;
    U(this, N, this.renderer.render);
    const e = this;
    Be(this.renderer), this.renderer.render = function(s, n) {
      const r = e.renderer.getRenderTarget();
      (r == null || "isXRRenderTarget" in r && r.isXRRenderTarget) && (t = 0, U(e, j, m(e, j) + 1), U(e, ee, m(e, ge).getDelta()), U(e, pe, m(e, pe) + m(e, ee)), e._fpsBuffer.shift(), e._fpsBuffer.push(1 / m(e, ee)), U(e, W, e._fpsBuffer.reduce((o, l) => o + l) / e._fpsBuffer.length), k && m(e, j) % 200 === 0 && console.log("FPS", Math.round(m(e, W)), "Interval:", m(e, C)));
      const i = t++;
      m(e, N).call(this, s, n), e.onAfterRender(s, n, i);
    };
  }
  disable() {
    m(this, N) && (this.renderer.render = m(this, N), U(this, N, void 0));
  }
  update(t, e) {
    this.internalUpdate(t, e);
  }
  onAfterRender(t, e, s) {
    if (this.pause)
      return;
    const r = this.renderer.renderLists.get(t, 0).opaque;
    let i = !0;
    if (r.length === 1) {
      const o = r[0].material;
      (o.name === "EffectMaterial" || o.name === "CopyShader") && (i = !1);
    }
    if ((e.parent && e.parent.type === "CubeCamera" || s >= 1 && e.type === "OrthographicCamera") && (i = !1), i) {
      if (tt || (this.updateInterval === "auto" ? m(this, W) < 40 && m(this, C) < 10 ? (U(this, C, m(this, C) + 1), k && console.warn("↓ Reducing LOD updates", m(this, C), m(this, W).toFixed(0))) : m(this, W) >= 60 && m(this, C) > 1 && (U(this, C, m(this, C) - 1), k && console.warn("↑ Increasing LOD updates", m(this, C), m(this, W).toFixed(0))) : U(this, C, this.updateInterval), m(this, C) > 0 && m(this, j) % m(this, C) != 0))
        return;
      this.internalUpdate(t, e);
    }
  }
  /**
   * Update LODs in a scene
   */
  internalUpdate(t, e) {
    var l, u;
    const s = this.renderer.renderLists.get(t, 0), n = s.opaque;
    this.projectionScreenMatrix.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse);
    const r = this.targetTriangleDensity;
    for (const c of n) {
      if (c.material && (((l = c.geometry) == null ? void 0 : l.type) === "BoxGeometry" || ((u = c.geometry) == null ? void 0 : u.type) === "BufferGeometry") && (c.material.name === "SphericalGaussianBlur" || c.material.name == "BackgroundCubeMaterial" || c.material.name === "CubemapFromEquirect" || c.material.name === "EquirectangularToCubeUV")) {
        k && (c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"] || (c.material["NEEDLE_PROGRESSIVE:IGNORE-WARNING"] = !0, console.warn("Ignoring skybox or BLIT object", c, c.material.name, c.material.type)));
        continue;
      }
      switch (c.material.type) {
        case "LineBasicMaterial":
        case "LineDashedMaterial":
        case "PointsMaterial":
        case "ShadowMaterial":
        case "MeshDistanceMaterial":
        case "MeshDepthMaterial":
          continue;
      }
      if (k === "color" && c.material && !c.object.progressive_debug_color) {
        c.object.progressive_debug_color = !0;
        const p = Math.random() * 16777215, M = new We({ color: p });
        c.object.material = M;
      }
      const g = c.object;
      (g instanceof H || g.isMesh) && this.updateLODs(t, e, g, r);
    }
    const i = s.transparent;
    for (const c of i) {
      const g = c.object;
      (g instanceof H || g.isMesh) && this.updateLODs(t, e, g, r);
    }
    const o = s.transmissive;
    for (const c of o) {
      const g = c.object;
      (g instanceof H || g.isMesh) && this.updateLODs(t, e, g, r);
    }
  }
  /** Update the LOD levels for the renderer. */
  updateLODs(t, e, s, n) {
    var o, l;
    s.userData || (s.userData = {});
    let r = s[De];
    if (r || (r = new st(), s[De] = r), r.frames++ < 2)
      return;
    for (const u of Y)
      (o = u.onBeforeUpdateLOD) == null || o.call(u, this.renderer, t, e, s);
    this.calculateLodLevel(e, s, r, n, R), R.mesh_lod = Math.round(R.mesh_lod), R.texture_lod = Math.round(R.texture_lod), R.mesh_lod >= 0 && this.loadProgressiveMeshes(s, R.mesh_lod);
    let i = R.texture_lod;
    if (s.material && i >= 0) {
      const u = s["DEBUG:LOD"];
      u != null && (i = u), this.loadProgressiveTextures(s.material, i);
    }
    for (const u of Y)
      (l = u.onAfterUpdatedLOD) == null || l.call(u, this.renderer, t, e, s, R);
    r.lastLodLevel_Mesh = R.mesh_lod, r.lastLodLevel_Texture = R.texture_lod;
  }
  /** Load progressive textures for the given material
   * @param material the material to load the textures for
   * @param level the LOD level to load. Level 0 is the best quality, higher levels are lower quality
   * @returns Promise with true if the LOD was loaded, false if not
   */
  loadProgressiveTextures(t, e) {
    if (!t)
      return;
    if (Array.isArray(t)) {
      for (const n of t)
        this.loadProgressiveTextures(n, e);
      return;
    }
    let s = !1;
    (t[J] === void 0 || e < t[J]) && (s = !0), s && (t[J] = e, _.assignTextureLOD(t, e).then((n) => {
      this._lodchangedlisteners.forEach((r) => r({ type: "texture", level: e, object: t }));
    }));
  }
  /** Load progressive meshes for the given mesh
   * @param mesh the mesh to load the LOD for
   * @param index the index of the mesh if it's part of a group
   * @param level the LOD level to load. Level 0 is the best quality, higher levels are lower quality
   * @returns Promise with true if the LOD was loaded, false if not
   */
  loadProgressiveMeshes(t, e) {
    if (!t)
      return Promise.resolve(null);
    if (t[J] !== e) {
      t[J] = e;
      const s = t.geometry;
      return _.assignMeshLOD(t, e).then((n) => (n && t[J] == e && s != t.geometry && this._lodchangedlisteners.forEach((r) => r({ type: "mesh", level: e, object: t })), n));
    }
    return Promise.resolve(null);
  }
  static isInside(t, e) {
    const s = t.min, n = t.max, r = (s.x + n.x) * 0.5, i = (s.y + n.y) * 0.5;
    return this._tempPtInside.set(r, i, s.z).applyMatrix4(e).z < 0;
  }
  calculateLodLevel(t, e, s, n, r) {
    var F;
    if (!e) {
      r.mesh_lod = -1, r.texture_lod = -1;
      return;
    }
    if (!t) {
      r.mesh_lod = -1, r.texture_lod = -1;
      return;
    }
    let o = 10 + 1, l = !1;
    if (k && e["DEBUG:LOD"] != null)
      return e["DEBUG:LOD"];
    const u = _.getMeshLODInformation(e.geometry), c = u == null ? void 0 : u.lods, g = c && c.length > 0, p = _.getMaterialMinMaxLODsCount(e.material), M = (p == null ? void 0 : p.min_count) != 1 / 0 && p.min_count > 0 && p.max_count > 0;
    if (!g && !M) {
      r.mesh_lod = 0, r.texture_lod = 0;
      return;
    }
    g || (l = !0, o = 0);
    const w = this.renderer.domElement.clientHeight || this.renderer.domElement.height;
    let L = e.geometry.boundingBox;
    if (e.type === "SkinnedMesh") {
      const D = e;
      if (!D.boundingBox)
        D.computeBoundingBox();
      else if (s.frames % 30 === 0) {
        const h = ye(D), B = D.geometry;
        h && (D.geometry = h), D.computeBoundingBox(), D.geometry = B;
      }
      L = D.boundingBox;
    }
    if (L && t.isPerspectiveCamera) {
      const D = t;
      if (e.geometry.attributes.color && e.geometry.attributes.color.count < 100 && e.geometry.boundingSphere) {
        this._sphere.copy(e.geometry.boundingSphere), this._sphere.applyMatrix4(e.matrixWorld);
        const f = t.getWorldPosition(this._tempWorldPosition);
        if (this._sphere.containsPoint(f)) {
          r.mesh_lod = 0, r.texture_lod = 0;
          return;
        }
      }
      if (this._tempBox.copy(L), this._tempBox.applyMatrix4(e.matrixWorld), P.isInside(this._tempBox, this.projectionScreenMatrix)) {
        r.mesh_lod = 0, r.texture_lod = 0;
        return;
      }
      if (this._tempBox.applyMatrix4(this.projectionScreenMatrix), this.renderer.xr.enabled && D.fov > 70) {
        const f = this._tempBox.min, y = this._tempBox.max;
        let O = f.x, b = f.y, E = y.x, X = y.y;
        const ae = 2, me = 1.5, le = (f.x + y.x) * 0.5, ce = (f.y + y.y) * 0.5;
        O = (O - le) * ae + le, b = (b - ce) * ae + ce, E = (E - le) * ae + le, X = (X - ce) * ae + ce;
        const Ge = O < 0 && E > 0 ? 0 : Math.min(Math.abs(f.x), Math.abs(y.x)), Fe = b < 0 && X > 0 ? 0 : Math.min(Math.abs(f.y), Math.abs(y.y)), xe = Math.max(Ge, Fe);
        s.lastCentrality = (me - xe) * (me - xe) * (me - xe);
      } else
        s.lastCentrality = 1;
      const h = this._tempBox.getSize(this._tempBoxSize);
      h.multiplyScalar(0.5), screen.availHeight > 0 && w > 0 && h.multiplyScalar(w / screen.availHeight), h.x *= D.aspect;
      const B = t.matrixWorldInverse, $ = this._tempBox2;
      $.copy(L), $.applyMatrix4(e.matrixWorld), $.applyMatrix4(B);
      const I = $.getSize(this._tempBox2Size), S = Math.max(I.x, I.y);
      if (Math.max(h.x, h.y) != 0 && S != 0 && (h.z = I.z / Math.max(I.x, I.y) * Math.max(h.x, h.y)), s.lastScreenCoverage = Math.max(h.x, h.y, h.z), s.lastScreenspaceVolume.copy(h), s.lastScreenCoverage *= s.lastCentrality, k && P.debugDrawLine) {
        const f = this.tempMatrix.copy(this.projectionScreenMatrix);
        f.invert();
        const y = P.corner0, O = P.corner1, b = P.corner2, E = P.corner3;
        y.copy(this._tempBox.min), O.copy(this._tempBox.max), O.x = y.x, b.copy(this._tempBox.max), b.y = y.y, E.copy(this._tempBox.max);
        const X = (y.z + E.z) * 0.5;
        y.z = O.z = b.z = E.z = X, y.applyMatrix4(f), O.applyMatrix4(f), b.applyMatrix4(f), E.applyMatrix4(f), P.debugDrawLine(y, O, 255), P.debugDrawLine(y, b, 255), P.debugDrawLine(O, E, 255), P.debugDrawLine(b, E, 255);
      }
      let T = 999;
      if (c && s.lastScreenCoverage > 0) {
        for (let f = 0; f < c.length; f++)
          if (c[f].density / s.lastScreenCoverage < n) {
            T = f;
            break;
          }
      }
      T < o && (o = T, l = !0);
    }
    if (l ? r.mesh_lod = o : r.mesh_lod = s.lastLodLevel_Mesh, k && r.mesh_lod != s.lastLodLevel_Mesh) {
      const h = c == null ? void 0 : c[r.mesh_lod];
      h && console.log(`Mesh LOD changed: ${s.lastLodLevel_Mesh} → ${r.mesh_lod} (${h.density.toFixed(0)}) - ${e.name}`);
    }
    if (M) {
      const D = "saveData" in globalThis.navigator && globalThis.navigator.saveData === !0;
      if (s.lastLodLevel_Texture < 0) {
        if (r.texture_lod = p.max_count - 1, k) {
          const h = p.lods[p.max_count - 1];
          k && console.log(`First Texture LOD ${r.texture_lod} (${h.max_height}px) - ${e.name}`);
        }
      } else {
        const h = s.lastScreenspaceVolume.x + s.lastScreenspaceVolume.y + s.lastScreenspaceVolume.z;
        let B = s.lastScreenCoverage * 2;
        ((F = this.context) == null ? void 0 : F.engine) === "model-viewer" && (B *= 2);
        const I = w / window.devicePixelRatio * B;
        for (let S = p.lods.length - 1; S >= 0; S--) {
          let q = p.lods[S];
          if (!(D && q.max_height >= 2048) && !(Qe() && q.max_height > 4096) && q.max_height > I) {
            if (r.texture_lod = S, r.texture_lod < s.lastLodLevel_Texture) {
              const T = q.max_height;
              k && console.log(`Texture LOD changed: ${s.lastLodLevel_Texture} → ${r.texture_lod} = ${T}px 
Screensize: ${I.toFixed(0)}px, Coverage: ${(100 * s.lastScreenCoverage).toFixed(2)}%, Volume ${h.toFixed(1)} 
${e.name}`);
            }
            break;
          }
        }
      }
    } else
      r.texture_lod = 0;
  }
};
let G = P;
C = new WeakMap(), N = new WeakMap(), ge = new WeakMap(), j = new WeakMap(), ee = new WeakMap(), pe = new WeakMap(), W = new WeakMap(), /** Assign a function to draw debug lines for the LODs. This function will be called with the start and end position of the line and the color of the line when the `debugprogressive` query parameter is set.
 */
d(G, "debugDrawLine"), d(G, "corner0", new z()), d(G, "corner1", new z()), d(G, "corner2", new z()), d(G, "corner3", new z()), d(G, "_tempPtInside", new z());
class st {
  constructor() {
    d(this, "frames", 0);
    d(this, "lastLodLevel_Mesh", -1);
    d(this, "lastLodLevel_Texture", -1);
    d(this, "lastScreenCoverage", 0);
    d(this, "lastScreenspaceVolume", new z());
    d(this, "lastCentrality", 0);
  }
}
const Ae = Symbol("NEEDLE_mesh_lod"), ue = Symbol("NEEDLE_texture_lod");
let ie = null;
function ke() {
  const a = rt();
  a && (a.mapURLs(function(t) {
    return Ee(), t;
  }), Ee(), ie == null || ie.disconnect(), ie = new MutationObserver((t) => {
    t.forEach((e) => {
      e.addedNodes.forEach((s) => {
        s instanceof HTMLElement && s.tagName.toLowerCase() === "model-viewer" && Re(s);
      });
    });
  }), ie.observe(document, { childList: !0, subtree: !0 }));
}
function rt() {
  if (typeof customElements > "u")
    return null;
  const a = customElements.get("model-viewer");
  return a || (customElements.whenDefined("model-viewer").then(() => {
    console.debug("[gltf-progressive] model-viewer defined"), ke();
  }), null);
}
function Ee() {
  if (typeof document > "u")
    return;
  document.querySelectorAll("model-viewer").forEach((t) => {
    Re(t);
  });
}
const Pe = /* @__PURE__ */ new WeakSet();
let it = 0;
function Re(a) {
  if (!a || Pe.has(a))
    return null;
  Pe.add(a), console.debug("[gltf-progressive] found new model-viewer..." + ++it + `
`, a.getAttribute("src"));
  let t = null, e = null, s = null;
  for (let n = a; n != null; n = Object.getPrototypeOf(n)) {
    const r = Object.getOwnPropertySymbols(n), i = r.find((u) => u.toString() == "Symbol(renderer)"), o = r.find((u) => u.toString() == "Symbol(scene)"), l = r.find((u) => u.toString() == "Symbol(needsRender)");
    !t && i != null && (t = a[i].threeRenderer), !e && o != null && (e = a[o]), !s && l != null && (s = a[l]);
  }
  if (t && e) {
    let n = function() {
      if (s) {
        let i = 0, o = setInterval(() => {
          if (i++ > 5) {
            clearInterval(o);
            return;
          }
          s == null || s.call(a);
        }, 300);
      }
    };
    console.debug("[gltf-progressive] setup model-viewer");
    const r = G.get(t, { engine: "model-viewer" });
    return G.addPlugin(new nt()), r.enable(), r.addEventListener("changed", () => {
      s == null || s.call(a);
    }), a.addEventListener("model-visibility", (i) => {
      i.detail.visible && (s == null || s.call(a));
    }), a.addEventListener("load", () => {
      n();
    }), () => {
      r.disable();
    };
  }
  return null;
}
class nt {
  constructor() {
    d(this, "_didWarnAboutMissingUrl", !1);
  }
  onBeforeUpdateLOD(t, e, s, n) {
    this.tryParseMeshLOD(e, n), this.tryParseTextureLOD(e, n);
  }
  getUrl(t) {
    if (!t)
      return null;
    let e = t.getAttribute("src");
    return e || (e = t.src), e || (this._didWarnAboutMissingUrl || console.warn("No url found in modelviewer", t), this._didWarnAboutMissingUrl = !0), e;
  }
  tryGetCurrentGLTF(t) {
    return t._currentGLTF;
  }
  tryGetCurrentModelViewer(t) {
    return t.element;
  }
  tryParseTextureLOD(t, e) {
    if (e[ue] == !0)
      return;
    e[ue] = !0;
    const s = this.tryGetCurrentGLTF(t), n = this.tryGetCurrentModelViewer(t), r = this.getUrl(n);
    if (r && s && e.material) {
      let i = function(l) {
        var c, g, p;
        if (l[ue] == !0)
          return;
        l[ue] = !0, l.userData && (l.userData.LOD = -1);
        const u = Object.keys(l);
        for (let M = 0; M < u.length; M++) {
          const w = u[M], L = l[w];
          if ((L == null ? void 0 : L.isTexture) === !0) {
            const F = (g = (c = L.userData) == null ? void 0 : c.associations) == null ? void 0 : g.textures;
            if (F == null)
              continue;
            const D = s.parser.json.textures[F];
            if (!D) {
              console.warn("Texture data not found for texture index " + F);
              continue;
            }
            if ((p = D == null ? void 0 : D.extensions) != null && p[V]) {
              const h = D.extensions[V];
              h && r && _.registerTexture(r, L, h.lods.length, F, h);
            }
          }
        }
      };
      const o = e.material;
      if (Array.isArray(o))
        for (const l of o)
          i(l);
      else
        i(o);
    }
  }
  tryParseMeshLOD(t, e) {
    var i, o;
    if (e[Ae] == !0)
      return;
    e[Ae] = !0;
    const s = this.tryGetCurrentModelViewer(t), n = this.getUrl(s);
    if (!n)
      return;
    const r = (o = (i = e.userData) == null ? void 0 : i.gltfExtensions) == null ? void 0 : o[V];
    if (r && n) {
      const l = e.uuid;
      _.registerMesh(n, l, e, 0, r.lods.length, r);
    }
  }
}
function pt(a, t, e, s) {
  Be(t), Ie(e), e.register((r) => new _(r, a));
  const n = G.get(t);
  return (s == null ? void 0 : s.enableLODsManager) !== !1 && n.enable(), n;
}
ke();
export {
  V as EXTENSION_NAME,
  G as LODsManager,
  _ as NEEDLE_progressive,
  Ce as VERSION,
  Ie as addDracoAndKTX2Loaders,
  Be as createLoaders,
  ye as getRaycastMesh,
  ke as patchModelViewer,
  Ze as registerRaycastMesh,
  dt as setDracoDecoderLocation,
  ht as setKTX2TranscoderLocation,
  pt as useNeedleProgressive,
  gt as useRaycastMeshes
};
